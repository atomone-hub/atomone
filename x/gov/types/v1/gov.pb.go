// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: atomone/gov/v1/gov.proto

package v1

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	types1 "github.com/cosmos/cosmos-sdk/codec/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/durationpb"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// VoteOption enumerates the valid vote options for a given governance proposal.
type VoteOption int32

const (
	// VOTE_OPTION_UNSPECIFIED defines a no-op vote option.
	VoteOption_VOTE_OPTION_UNSPECIFIED VoteOption = 0
	// VOTE_OPTION_YES defines a yes vote option.
	VoteOption_VOTE_OPTION_YES VoteOption = 1
	// VOTE_OPTION_ABSTAIN defines an abstain vote option.
	VoteOption_VOTE_OPTION_ABSTAIN VoteOption = 2
	// VOTE_OPTION_NO defines a no vote option.
	VoteOption_VOTE_OPTION_NO VoteOption = 3
)

var VoteOption_name = map[int32]string{
	0: "VOTE_OPTION_UNSPECIFIED",
	1: "VOTE_OPTION_YES",
	2: "VOTE_OPTION_ABSTAIN",
	3: "VOTE_OPTION_NO",
}

var VoteOption_value = map[string]int32{
	"VOTE_OPTION_UNSPECIFIED": 0,
	"VOTE_OPTION_YES":         1,
	"VOTE_OPTION_ABSTAIN":     2,
	"VOTE_OPTION_NO":          3,
}

func (x VoteOption) String() string {
	return proto.EnumName(VoteOption_name, int32(x))
}

func (VoteOption) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ecf0f9950ff6986c, []int{0}
}

// ProposalStatus enumerates the valid statuses of a proposal.
type ProposalStatus int32

const (
	// PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.
	ProposalStatus_PROPOSAL_STATUS_UNSPECIFIED ProposalStatus = 0
	// PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
	// period.
	ProposalStatus_PROPOSAL_STATUS_DEPOSIT_PERIOD ProposalStatus = 1
	// PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
	// period.
	ProposalStatus_PROPOSAL_STATUS_VOTING_PERIOD ProposalStatus = 2
	// PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
	// passed.
	ProposalStatus_PROPOSAL_STATUS_PASSED ProposalStatus = 3
	// PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
	// been rejected.
	ProposalStatus_PROPOSAL_STATUS_REJECTED ProposalStatus = 4
	// PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
	// failed.
	ProposalStatus_PROPOSAL_STATUS_FAILED ProposalStatus = 5
	// PROPOSAL_STATUS_VETOED defines a proposal status of a proposal that has
	// been vetoed.
	ProposalStatus_PROPOSAL_STATUS_VETOED ProposalStatus = 6
)

var ProposalStatus_name = map[int32]string{
	0: "PROPOSAL_STATUS_UNSPECIFIED",
	1: "PROPOSAL_STATUS_DEPOSIT_PERIOD",
	2: "PROPOSAL_STATUS_VOTING_PERIOD",
	3: "PROPOSAL_STATUS_PASSED",
	4: "PROPOSAL_STATUS_REJECTED",
	5: "PROPOSAL_STATUS_FAILED",
	6: "PROPOSAL_STATUS_VETOED",
}

var ProposalStatus_value = map[string]int32{
	"PROPOSAL_STATUS_UNSPECIFIED":    0,
	"PROPOSAL_STATUS_DEPOSIT_PERIOD": 1,
	"PROPOSAL_STATUS_VOTING_PERIOD":  2,
	"PROPOSAL_STATUS_PASSED":         3,
	"PROPOSAL_STATUS_REJECTED":       4,
	"PROPOSAL_STATUS_FAILED":         5,
	"PROPOSAL_STATUS_VETOED":         6,
}

func (x ProposalStatus) String() string {
	return proto.EnumName(ProposalStatus_name, int32(x))
}

func (ProposalStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ecf0f9950ff6986c, []int{1}
}

// WeightedVoteOption defines a unit of vote for vote split.
type WeightedVoteOption struct {
	// option defines the valid vote options, it must not contain duplicate vote
	// options.
	Option VoteOption `protobuf:"varint,1,opt,name=option,proto3,enum=atomone.gov.v1.VoteOption" json:"option,omitempty"`
	// weight is the vote weight associated with the vote option.
	Weight string `protobuf:"bytes,2,opt,name=weight,proto3" json:"weight,omitempty"`
}

func (m *WeightedVoteOption) Reset()         { *m = WeightedVoteOption{} }
func (m *WeightedVoteOption) String() string { return proto.CompactTextString(m) }
func (*WeightedVoteOption) ProtoMessage()    {}
func (*WeightedVoteOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_ecf0f9950ff6986c, []int{0}
}
func (m *WeightedVoteOption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WeightedVoteOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WeightedVoteOption.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WeightedVoteOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WeightedVoteOption.Merge(m, src)
}
func (m *WeightedVoteOption) XXX_Size() int {
	return m.Size()
}
func (m *WeightedVoteOption) XXX_DiscardUnknown() {
	xxx_messageInfo_WeightedVoteOption.DiscardUnknown(m)
}

var xxx_messageInfo_WeightedVoteOption proto.InternalMessageInfo

func (m *WeightedVoteOption) GetOption() VoteOption {
	if m != nil {
		return m.Option
	}
	return VoteOption_VOTE_OPTION_UNSPECIFIED
}

func (m *WeightedVoteOption) GetWeight() string {
	if m != nil {
		return m.Weight
	}
	return ""
}

// Deposit defines an amount deposited by an account address to an active
// proposal.
type Deposit struct {
	// proposal_id defines the unique id of the proposal.
	ProposalId uint64 `protobuf:"varint,1,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	// depositor defines the deposit addresses from the proposals.
	Depositor string `protobuf:"bytes,2,opt,name=depositor,proto3" json:"depositor,omitempty"`
	// amount to be deposited by depositor.
	Amount []types.Coin `protobuf:"bytes,3,rep,name=amount,proto3" json:"amount"`
}

func (m *Deposit) Reset()         { *m = Deposit{} }
func (m *Deposit) String() string { return proto.CompactTextString(m) }
func (*Deposit) ProtoMessage()    {}
func (*Deposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_ecf0f9950ff6986c, []int{1}
}
func (m *Deposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Deposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Deposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Deposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Deposit.Merge(m, src)
}
func (m *Deposit) XXX_Size() int {
	return m.Size()
}
func (m *Deposit) XXX_DiscardUnknown() {
	xxx_messageInfo_Deposit.DiscardUnknown(m)
}

var xxx_messageInfo_Deposit proto.InternalMessageInfo

func (m *Deposit) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

func (m *Deposit) GetDepositor() string {
	if m != nil {
		return m.Depositor
	}
	return ""
}

func (m *Deposit) GetAmount() []types.Coin {
	if m != nil {
		return m.Amount
	}
	return nil
}

// LastMinDeposit is a record of the last time the minimum deposit
// was updated in the store, both its value and a timestamp
type LastMinDeposit struct {
	// value is the value of the minimum deposit
	Value []types.Coin `protobuf:"bytes,1,rep,name=value,proto3" json:"value"`
	// time is the time the minimum deposit was last updated
	Time *time.Time `protobuf:"bytes,2,opt,name=time,proto3,stdtime" json:"time,omitempty"`
}

func (m *LastMinDeposit) Reset()         { *m = LastMinDeposit{} }
func (m *LastMinDeposit) String() string { return proto.CompactTextString(m) }
func (*LastMinDeposit) ProtoMessage()    {}
func (*LastMinDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_ecf0f9950ff6986c, []int{2}
}
func (m *LastMinDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LastMinDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LastMinDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LastMinDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LastMinDeposit.Merge(m, src)
}
func (m *LastMinDeposit) XXX_Size() int {
	return m.Size()
}
func (m *LastMinDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_LastMinDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_LastMinDeposit proto.InternalMessageInfo

func (m *LastMinDeposit) GetValue() []types.Coin {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *LastMinDeposit) GetTime() *time.Time {
	if m != nil {
		return m.Time
	}
	return nil
}

// Proposal defines the core field members of a governance proposal.
type Proposal struct {
	// id defines the unique id of the proposal.
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// messages are the arbitrary messages to be executed if the proposal passes.
	Messages []*types1.Any `protobuf:"bytes,2,rep,name=messages,proto3" json:"messages,omitempty"`
	// status defines the proposal status.
	Status ProposalStatus `protobuf:"varint,3,opt,name=status,proto3,enum=atomone.gov.v1.ProposalStatus" json:"status,omitempty"`
	// final_tally_result is the final tally result of the proposal. When
	// querying a proposal via gRPC, this field is not populated until the
	// proposal's voting period has ended.
	FinalTallyResult *TallyResult `protobuf:"bytes,4,opt,name=final_tally_result,json=finalTallyResult,proto3" json:"final_tally_result,omitempty"`
	// submit_time is the time of proposal submission.
	SubmitTime *time.Time `protobuf:"bytes,5,opt,name=submit_time,json=submitTime,proto3,stdtime" json:"submit_time,omitempty"`
	// deposit_end_time is the end time for deposition.
	DepositEndTime *time.Time `protobuf:"bytes,6,opt,name=deposit_end_time,json=depositEndTime,proto3,stdtime" json:"deposit_end_time,omitempty"`
	// total_deposit is the total deposit on the proposal.
	TotalDeposit []types.Coin `protobuf:"bytes,7,rep,name=total_deposit,json=totalDeposit,proto3" json:"total_deposit"`
	// voting_start_time is the starting time to vote on a proposal.
	VotingStartTime *time.Time `protobuf:"bytes,8,opt,name=voting_start_time,json=votingStartTime,proto3,stdtime" json:"voting_start_time,omitempty"`
	// voting_end_time is the end time of voting on a proposal.
	VotingEndTime *time.Time `protobuf:"bytes,9,opt,name=voting_end_time,json=votingEndTime,proto3,stdtime" json:"voting_end_time,omitempty"`
	// metadata is any arbitrary metadata attached to the proposal.
	Metadata string `protobuf:"bytes,10,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// title is the title of the proposal
	//
	// Since: cosmos-sdk 0.47
	Title string `protobuf:"bytes,11,opt,name=title,proto3" json:"title,omitempty"`
	// summary is a short summary of the proposal
	//
	// Since: cosmos-sdk 0.47
	Summary string `protobuf:"bytes,12,opt,name=summary,proto3" json:"summary,omitempty"`
	// Proposer is the address of the proposal sumbitter
	//
	// Since: cosmos-sdk 0.47
	Proposer string `protobuf:"bytes,13,opt,name=proposer,proto3" json:"proposer,omitempty"`
	// endorsed is a boolean indicating whether the proposal has been endorsed
	// by the Steering DAO.
	Endorsed bool `protobuf:"varint,14,opt,name=endorsed,proto3" json:"endorsed,omitempty"`
	// annotation is an optional field that contains annotations
	// added by the Steering DAO.
	Annotation string `protobuf:"bytes,15,opt,name=annotation,proto3" json:"annotation,omitempty"`
	// times_voting_period_extended is the number of times the voting period
	// has been extended from one of the core DAOs.
	TimesVotingPeriodExtended uint32 `protobuf:"varint,16,opt,name=times_voting_period_extended,json=timesVotingPeriodExtended,proto3" json:"times_voting_period_extended,omitempty"`
}

func (m *Proposal) Reset()         { *m = Proposal{} }
func (m *Proposal) String() string { return proto.CompactTextString(m) }
func (*Proposal) ProtoMessage()    {}
func (*Proposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_ecf0f9950ff6986c, []int{3}
}
func (m *Proposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Proposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Proposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Proposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proposal.Merge(m, src)
}
func (m *Proposal) XXX_Size() int {
	return m.Size()
}
func (m *Proposal) XXX_DiscardUnknown() {
	xxx_messageInfo_Proposal.DiscardUnknown(m)
}

var xxx_messageInfo_Proposal proto.InternalMessageInfo

func (m *Proposal) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Proposal) GetMessages() []*types1.Any {
	if m != nil {
		return m.Messages
	}
	return nil
}

func (m *Proposal) GetStatus() ProposalStatus {
	if m != nil {
		return m.Status
	}
	return ProposalStatus_PROPOSAL_STATUS_UNSPECIFIED
}

func (m *Proposal) GetFinalTallyResult() *TallyResult {
	if m != nil {
		return m.FinalTallyResult
	}
	return nil
}

func (m *Proposal) GetSubmitTime() *time.Time {
	if m != nil {
		return m.SubmitTime
	}
	return nil
}

func (m *Proposal) GetDepositEndTime() *time.Time {
	if m != nil {
		return m.DepositEndTime
	}
	return nil
}

func (m *Proposal) GetTotalDeposit() []types.Coin {
	if m != nil {
		return m.TotalDeposit
	}
	return nil
}

func (m *Proposal) GetVotingStartTime() *time.Time {
	if m != nil {
		return m.VotingStartTime
	}
	return nil
}

func (m *Proposal) GetVotingEndTime() *time.Time {
	if m != nil {
		return m.VotingEndTime
	}
	return nil
}

func (m *Proposal) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *Proposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Proposal) GetSummary() string {
	if m != nil {
		return m.Summary
	}
	return ""
}

func (m *Proposal) GetProposer() string {
	if m != nil {
		return m.Proposer
	}
	return ""
}

func (m *Proposal) GetEndorsed() bool {
	if m != nil {
		return m.Endorsed
	}
	return false
}

func (m *Proposal) GetAnnotation() string {
	if m != nil {
		return m.Annotation
	}
	return ""
}

func (m *Proposal) GetTimesVotingPeriodExtended() uint32 {
	if m != nil {
		return m.TimesVotingPeriodExtended
	}
	return 0
}

// TallyResult defines a standard tally for a governance proposal.
type TallyResult struct {
	// yes_count is the number of yes votes on a proposal.
	YesCount string `protobuf:"bytes,1,opt,name=yes_count,json=yesCount,proto3" json:"yes_count,omitempty"`
	// abstain_count is the number of abstain votes on a proposal.
	AbstainCount string `protobuf:"bytes,2,opt,name=abstain_count,json=abstainCount,proto3" json:"abstain_count,omitempty"`
	// no_count is the number of no votes on a proposal.
	NoCount string `protobuf:"bytes,3,opt,name=no_count,json=noCount,proto3" json:"no_count,omitempty"`
}

func (m *TallyResult) Reset()         { *m = TallyResult{} }
func (m *TallyResult) String() string { return proto.CompactTextString(m) }
func (*TallyResult) ProtoMessage()    {}
func (*TallyResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_ecf0f9950ff6986c, []int{4}
}
func (m *TallyResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TallyResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TallyResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TallyResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TallyResult.Merge(m, src)
}
func (m *TallyResult) XXX_Size() int {
	return m.Size()
}
func (m *TallyResult) XXX_DiscardUnknown() {
	xxx_messageInfo_TallyResult.DiscardUnknown(m)
}

var xxx_messageInfo_TallyResult proto.InternalMessageInfo

func (m *TallyResult) GetYesCount() string {
	if m != nil {
		return m.YesCount
	}
	return ""
}

func (m *TallyResult) GetAbstainCount() string {
	if m != nil {
		return m.AbstainCount
	}
	return ""
}

func (m *TallyResult) GetNoCount() string {
	if m != nil {
		return m.NoCount
	}
	return ""
}

// Vote defines a vote on a governance proposal.
// A Vote consists of a proposal ID, the voter, and the vote option.
type Vote struct {
	// proposal_id defines the unique id of the proposal.
	ProposalId uint64 `protobuf:"varint,1,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	// voter is the voter address of the proposal.
	Voter string `protobuf:"bytes,2,opt,name=voter,proto3" json:"voter,omitempty"`
	// options is the weighted vote options.
	Options []*WeightedVoteOption `protobuf:"bytes,4,rep,name=options,proto3" json:"options,omitempty"`
	// metadata is any  arbitrary metadata to attached to the vote.
	Metadata string `protobuf:"bytes,5,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *Vote) Reset()         { *m = Vote{} }
func (m *Vote) String() string { return proto.CompactTextString(m) }
func (*Vote) ProtoMessage()    {}
func (*Vote) Descriptor() ([]byte, []int) {
	return fileDescriptor_ecf0f9950ff6986c, []int{5}
}
func (m *Vote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vote.Merge(m, src)
}
func (m *Vote) XXX_Size() int {
	return m.Size()
}
func (m *Vote) XXX_DiscardUnknown() {
	xxx_messageInfo_Vote.DiscardUnknown(m)
}

var xxx_messageInfo_Vote proto.InternalMessageInfo

func (m *Vote) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

func (m *Vote) GetVoter() string {
	if m != nil {
		return m.Voter
	}
	return ""
}

func (m *Vote) GetOptions() []*WeightedVoteOption {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *Vote) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

// QuorumCheckQueueEntry defines a quorum check queue entry.
type QuorumCheckQueueEntry struct {
	// quorum_timeout_time is the time after which quorum checks start happening
	// and voting period is extended if proposal reaches quorum.
	QuorumTimeoutTime *time.Time `protobuf:"bytes,1,opt,name=quorum_timeout_time,json=quorumTimeoutTime,proto3,stdtime" json:"quorum_timeout_time,omitempty"`
	// quorum_check_count is the number of times quorum will be checked.
	// This is a snapshot of the parameter value with the same name when the
	// proposal is initially added to the queue.
	QuorumCheckCount uint64 `protobuf:"varint,2,opt,name=quorum_check_count,json=quorumCheckCount,proto3" json:"quorum_check_count,omitempty"`
	// quorum_checks_done is the number of quorum checks that have been done.
	QuorumChecksDone uint64 `protobuf:"varint,3,opt,name=quorum_checks_done,json=quorumChecksDone,proto3" json:"quorum_checks_done,omitempty"`
}

func (m *QuorumCheckQueueEntry) Reset()         { *m = QuorumCheckQueueEntry{} }
func (m *QuorumCheckQueueEntry) String() string { return proto.CompactTextString(m) }
func (*QuorumCheckQueueEntry) ProtoMessage()    {}
func (*QuorumCheckQueueEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_ecf0f9950ff6986c, []int{6}
}
func (m *QuorumCheckQueueEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuorumCheckQueueEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuorumCheckQueueEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuorumCheckQueueEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuorumCheckQueueEntry.Merge(m, src)
}
func (m *QuorumCheckQueueEntry) XXX_Size() int {
	return m.Size()
}
func (m *QuorumCheckQueueEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_QuorumCheckQueueEntry.DiscardUnknown(m)
}

var xxx_messageInfo_QuorumCheckQueueEntry proto.InternalMessageInfo

func (m *QuorumCheckQueueEntry) GetQuorumTimeoutTime() *time.Time {
	if m != nil {
		return m.QuorumTimeoutTime
	}
	return nil
}

func (m *QuorumCheckQueueEntry) GetQuorumCheckCount() uint64 {
	if m != nil {
		return m.QuorumCheckCount
	}
	return 0
}

func (m *QuorumCheckQueueEntry) GetQuorumChecksDone() uint64 {
	if m != nil {
		return m.QuorumChecksDone
	}
	return 0
}

// DepositParams defines the params for deposits on governance proposals.
type DepositParams struct {
	// Minimum deposit for a proposal to enter voting period.
	MinDeposit []types.Coin `protobuf:"bytes,1,rep,name=min_deposit,json=minDeposit,proto3" json:"min_deposit,omitempty"`
	// Maximum period for Atom holders to deposit on a proposal. Initial value: 2
	// months.
	MaxDepositPeriod *time.Duration `protobuf:"bytes,2,opt,name=max_deposit_period,json=maxDepositPeriod,proto3,stdduration" json:"max_deposit_period,omitempty"`
}

func (m *DepositParams) Reset()         { *m = DepositParams{} }
func (m *DepositParams) String() string { return proto.CompactTextString(m) }
func (*DepositParams) ProtoMessage()    {}
func (*DepositParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_ecf0f9950ff6986c, []int{7}
}
func (m *DepositParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DepositParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DepositParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DepositParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DepositParams.Merge(m, src)
}
func (m *DepositParams) XXX_Size() int {
	return m.Size()
}
func (m *DepositParams) XXX_DiscardUnknown() {
	xxx_messageInfo_DepositParams.DiscardUnknown(m)
}

var xxx_messageInfo_DepositParams proto.InternalMessageInfo

func (m *DepositParams) GetMinDeposit() []types.Coin {
	if m != nil {
		return m.MinDeposit
	}
	return nil
}

func (m *DepositParams) GetMaxDepositPeriod() *time.Duration {
	if m != nil {
		return m.MaxDepositPeriod
	}
	return nil
}

// VotingParams defines the params for voting on governance proposals.
type VotingParams struct {
	// Duration of the voting period.
	VotingPeriod *time.Duration `protobuf:"bytes,1,opt,name=voting_period,json=votingPeriod,proto3,stdduration" json:"voting_period,omitempty"`
}

func (m *VotingParams) Reset()         { *m = VotingParams{} }
func (m *VotingParams) String() string { return proto.CompactTextString(m) }
func (*VotingParams) ProtoMessage()    {}
func (*VotingParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_ecf0f9950ff6986c, []int{8}
}
func (m *VotingParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VotingParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VotingParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VotingParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VotingParams.Merge(m, src)
}
func (m *VotingParams) XXX_Size() int {
	return m.Size()
}
func (m *VotingParams) XXX_DiscardUnknown() {
	xxx_messageInfo_VotingParams.DiscardUnknown(m)
}

var xxx_messageInfo_VotingParams proto.InternalMessageInfo

func (m *VotingParams) GetVotingPeriod() *time.Duration {
	if m != nil {
		return m.VotingPeriod
	}
	return nil
}

// TallyParams defines the params for tallying votes on governance proposals.
type TallyParams struct {
	// Minimum percentage of total stake needed to vote for a result to be
	// considered valid.
	Quorum string `protobuf:"bytes,1,opt,name=quorum,proto3" json:"quorum,omitempty"` // Deprecated: Do not use.
	// Minimum proportion of Yes votes for proposal to pass. Default value: 2/3.
	Threshold string `protobuf:"bytes,2,opt,name=threshold,proto3" json:"threshold,omitempty"`
	// quorum for constitution amendment proposals
	ConstitutionAmendmentQuorum string `protobuf:"bytes,3,opt,name=constitution_amendment_quorum,json=constitutionAmendmentQuorum,proto3" json:"constitution_amendment_quorum,omitempty"` // Deprecated: Do not use.
	// Minimum proportion of Yes votes for a Constitution Amendment proposal to pass. Default value: 0.9.
	ConstitutionAmendmentThreshold string `protobuf:"bytes,4,opt,name=constitution_amendment_threshold,json=constitutionAmendmentThreshold,proto3" json:"constitution_amendment_threshold,omitempty"`
	// quorum for law proposals
	LawQuorum string `protobuf:"bytes,5,opt,name=law_quorum,json=lawQuorum,proto3" json:"law_quorum,omitempty"` // Deprecated: Do not use.
	// Minimum proportion of Yes votes for a Law proposal to pass. Default value: 0.9.
	LawThreshold string `protobuf:"bytes,6,opt,name=law_threshold,json=lawThreshold,proto3" json:"law_threshold,omitempty"`
}

func (m *TallyParams) Reset()         { *m = TallyParams{} }
func (m *TallyParams) String() string { return proto.CompactTextString(m) }
func (*TallyParams) ProtoMessage()    {}
func (*TallyParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_ecf0f9950ff6986c, []int{9}
}
func (m *TallyParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TallyParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TallyParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TallyParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TallyParams.Merge(m, src)
}
func (m *TallyParams) XXX_Size() int {
	return m.Size()
}
func (m *TallyParams) XXX_DiscardUnknown() {
	xxx_messageInfo_TallyParams.DiscardUnknown(m)
}

var xxx_messageInfo_TallyParams proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *TallyParams) GetQuorum() string {
	if m != nil {
		return m.Quorum
	}
	return ""
}

func (m *TallyParams) GetThreshold() string {
	if m != nil {
		return m.Threshold
	}
	return ""
}

// Deprecated: Do not use.
func (m *TallyParams) GetConstitutionAmendmentQuorum() string {
	if m != nil {
		return m.ConstitutionAmendmentQuorum
	}
	return ""
}

func (m *TallyParams) GetConstitutionAmendmentThreshold() string {
	if m != nil {
		return m.ConstitutionAmendmentThreshold
	}
	return ""
}

// Deprecated: Do not use.
func (m *TallyParams) GetLawQuorum() string {
	if m != nil {
		return m.LawQuorum
	}
	return ""
}

func (m *TallyParams) GetLawThreshold() string {
	if m != nil {
		return m.LawThreshold
	}
	return ""
}

type MinDepositThrottler struct {
	// Floor value for the minimum deposit required for a proposal to enter the voting period.
	FloorValue []types.Coin `protobuf:"bytes,1,rep,name=floor_value,json=floorValue,proto3" json:"floor_value"`
	// Duration that dictates after how long the dynamic minimum deposit should be recalculated
	// for time-based decreases.
	UpdatePeriod *time.Duration `protobuf:"bytes,2,opt,name=update_period,json=updatePeriod,proto3,stdduration" json:"update_period,omitempty"`
	// The number of active proposals the dynamic minimum deposit should target.
	TargetActiveProposals uint64 `protobuf:"varint,3,opt,name=target_active_proposals,json=targetActiveProposals,proto3" json:"target_active_proposals,omitempty"`
	// The ratio of increase for the minimum deposit when the number of active proposals
	// is at or above the target.
	IncreaseRatio string `protobuf:"bytes,4,opt,name=increase_ratio,json=increaseRatio,proto3" json:"increase_ratio,omitempty"`
	// The ratio of decrease for the minimum deposit when the number of active proposals
	// is 1 less than the target.
	DecreaseRatio string `protobuf:"bytes,5,opt,name=decrease_ratio,json=decreaseRatio,proto3" json:"decrease_ratio,omitempty"`
	// A positive integer representing the sensitivity of dynamic minimum deposit
	// decreases to the distance from the target number of active proposals.
	// The higher the number, the lower the sensitivity. A value of 1 represents the
	// highest sensitivity.
	DecreaseSensitivityTargetDistance uint64 `protobuf:"varint,6,opt,name=decrease_sensitivity_target_distance,json=decreaseSensitivityTargetDistance,proto3" json:"decrease_sensitivity_target_distance,omitempty"`
}

func (m *MinDepositThrottler) Reset()         { *m = MinDepositThrottler{} }
func (m *MinDepositThrottler) String() string { return proto.CompactTextString(m) }
func (*MinDepositThrottler) ProtoMessage()    {}
func (*MinDepositThrottler) Descriptor() ([]byte, []int) {
	return fileDescriptor_ecf0f9950ff6986c, []int{10}
}
func (m *MinDepositThrottler) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MinDepositThrottler) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MinDepositThrottler.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MinDepositThrottler) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MinDepositThrottler.Merge(m, src)
}
func (m *MinDepositThrottler) XXX_Size() int {
	return m.Size()
}
func (m *MinDepositThrottler) XXX_DiscardUnknown() {
	xxx_messageInfo_MinDepositThrottler.DiscardUnknown(m)
}

var xxx_messageInfo_MinDepositThrottler proto.InternalMessageInfo

func (m *MinDepositThrottler) GetFloorValue() []types.Coin {
	if m != nil {
		return m.FloorValue
	}
	return nil
}

func (m *MinDepositThrottler) GetUpdatePeriod() *time.Duration {
	if m != nil {
		return m.UpdatePeriod
	}
	return nil
}

func (m *MinDepositThrottler) GetTargetActiveProposals() uint64 {
	if m != nil {
		return m.TargetActiveProposals
	}
	return 0
}

func (m *MinDepositThrottler) GetIncreaseRatio() string {
	if m != nil {
		return m.IncreaseRatio
	}
	return ""
}

func (m *MinDepositThrottler) GetDecreaseRatio() string {
	if m != nil {
		return m.DecreaseRatio
	}
	return ""
}

func (m *MinDepositThrottler) GetDecreaseSensitivityTargetDistance() uint64 {
	if m != nil {
		return m.DecreaseSensitivityTargetDistance
	}
	return 0
}

type MinInitialDepositThrottler struct {
	// Floor value for the minimum initial deposit required for a proposal to enter the deposit period.
	FloorValue []types.Coin `protobuf:"bytes,1,rep,name=floor_value,json=floorValue,proto3" json:"floor_value"`
	// Duration that dictates after how long the dynamic minimum deposit should be recalculated
	// for time-based decreases.
	UpdatePeriod *time.Duration `protobuf:"bytes,2,opt,name=update_period,json=updatePeriod,proto3,stdduration" json:"update_period,omitempty"`
	// The number of proposals in deposit period the dynamic minimum initial deposit should target.
	TargetProposals uint64 `protobuf:"varint,3,opt,name=target_proposals,json=targetProposals,proto3" json:"target_proposals,omitempty"`
	// The ratio of increase for the minimum initial deposit when the number of proposals
	// in deposit period is at or above the target.
	IncreaseRatio string `protobuf:"bytes,4,opt,name=increase_ratio,json=increaseRatio,proto3" json:"increase_ratio,omitempty"`
	// The ratio of decrease for the minimum initial deposit when the number of proposals
	// in deposit period is 1 less than the target.
	DecreaseRatio string `protobuf:"bytes,5,opt,name=decrease_ratio,json=decreaseRatio,proto3" json:"decrease_ratio,omitempty"`
	// A positive integer representing the sensitivity of dynamic minimum initial
	// deposit decreases to the distance from the target number of proposals
	// in deposit period. The higher the number, the lower the sensitivity. A value
	// of 1 represents the highest sensitivity.
	DecreaseSensitivityTargetDistance uint64 `protobuf:"varint,6,opt,name=decrease_sensitivity_target_distance,json=decreaseSensitivityTargetDistance,proto3" json:"decrease_sensitivity_target_distance,omitempty"`
}

func (m *MinInitialDepositThrottler) Reset()         { *m = MinInitialDepositThrottler{} }
func (m *MinInitialDepositThrottler) String() string { return proto.CompactTextString(m) }
func (*MinInitialDepositThrottler) ProtoMessage()    {}
func (*MinInitialDepositThrottler) Descriptor() ([]byte, []int) {
	return fileDescriptor_ecf0f9950ff6986c, []int{11}
}
func (m *MinInitialDepositThrottler) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MinInitialDepositThrottler) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MinInitialDepositThrottler.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MinInitialDepositThrottler) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MinInitialDepositThrottler.Merge(m, src)
}
func (m *MinInitialDepositThrottler) XXX_Size() int {
	return m.Size()
}
func (m *MinInitialDepositThrottler) XXX_DiscardUnknown() {
	xxx_messageInfo_MinInitialDepositThrottler.DiscardUnknown(m)
}

var xxx_messageInfo_MinInitialDepositThrottler proto.InternalMessageInfo

func (m *MinInitialDepositThrottler) GetFloorValue() []types.Coin {
	if m != nil {
		return m.FloorValue
	}
	return nil
}

func (m *MinInitialDepositThrottler) GetUpdatePeriod() *time.Duration {
	if m != nil {
		return m.UpdatePeriod
	}
	return nil
}

func (m *MinInitialDepositThrottler) GetTargetProposals() uint64 {
	if m != nil {
		return m.TargetProposals
	}
	return 0
}

func (m *MinInitialDepositThrottler) GetIncreaseRatio() string {
	if m != nil {
		return m.IncreaseRatio
	}
	return ""
}

func (m *MinInitialDepositThrottler) GetDecreaseRatio() string {
	if m != nil {
		return m.DecreaseRatio
	}
	return ""
}

func (m *MinInitialDepositThrottler) GetDecreaseSensitivityTargetDistance() uint64 {
	if m != nil {
		return m.DecreaseSensitivityTargetDistance
	}
	return 0
}

// Params defines the parameters for the x/gov module.
//
// Since: cosmos-sdk 0.47
type Params struct {
	// Minimum deposit for a proposal to enter voting period.
	// Deprecated: a dynamic system now determines the minimum deposit,
	// see the other params inside the min_deposit_throttler field.
	// While setting this value returns an error, when queried it is set to the
	// value of the current minimum deposit value as determined by the dynamic
	// system for backward compatibility.
	MinDeposit []types.Coin `protobuf:"bytes,1,rep,name=min_deposit,json=minDeposit,proto3" json:"min_deposit"` // Deprecated: Do not use.
	// Maximum period for Atom holders to deposit on a proposal. Initial value: 2
	// months.
	MaxDepositPeriod *time.Duration `protobuf:"bytes,2,opt,name=max_deposit_period,json=maxDepositPeriod,proto3,stdduration" json:"max_deposit_period,omitempty"`
	// Duration of the voting period.
	VotingPeriod *time.Duration `protobuf:"bytes,3,opt,name=voting_period,json=votingPeriod,proto3,stdduration" json:"voting_period,omitempty"`
	// Minimum percentage of total stake needed to vote for a result to be
	// considered valid. Default value: 0.25.
	Quorum string `protobuf:"bytes,4,opt,name=quorum,proto3" json:"quorum,omitempty"` // Deprecated: Do not use.
	// Minimum proportion of Yes votes for proposal to pass. Default value: 2/3.
	Threshold string `protobuf:"bytes,5,opt,name=threshold,proto3" json:"threshold,omitempty"`
	// The ratio representing the proportion of the deposit value that must be paid at proposal submission.
	MinInitialDepositRatio string `protobuf:"bytes,7,opt,name=min_initial_deposit_ratio,json=minInitialDepositRatio,proto3" json:"min_initial_deposit_ratio,omitempty"` // Deprecated: Do not use.
	// burn deposits if a proposal does not meet quorum
	BurnVoteQuorum bool `protobuf:"varint,13,opt,name=burn_vote_quorum,json=burnVoteQuorum,proto3" json:"burn_vote_quorum,omitempty"`
	// burn deposits if the proposal does not enter voting period
	BurnProposalDepositPrevote bool `protobuf:"varint,14,opt,name=burn_proposal_deposit_prevote,json=burnProposalDepositPrevote,proto3" json:"burn_proposal_deposit_prevote,omitempty"`
	// The ratio representing the proportion of the deposit value minimum that
	// must be met when making a deposit. Default value: 0.01. Meaning that for a
	// chain with a min_deposit of 100stake, a deposit of 1stake would be
	// required.
	//
	// Since: cosmos-sdk 0.50
	// NOTE: backported from v50 (https://github.com/cosmos/cosmos-sdk/pull/18146)
	MinDepositRatio string `protobuf:"bytes,15,opt,name=min_deposit_ratio,json=minDepositRatio,proto3" json:"min_deposit_ratio,omitempty"`
	// quorum for constitution amendment proposals
	ConstitutionAmendmentQuorum string `protobuf:"bytes,16,opt,name=constitution_amendment_quorum,json=constitutionAmendmentQuorum,proto3" json:"constitution_amendment_quorum,omitempty"` // Deprecated: Do not use.
	// Minimum proportion of Yes votes for a Constitution Amendment proposal to pass. Default value: 0.9.
	ConstitutionAmendmentThreshold string `protobuf:"bytes,17,opt,name=constitution_amendment_threshold,json=constitutionAmendmentThreshold,proto3" json:"constitution_amendment_threshold,omitempty"`
	// quorum for law proposals
	LawQuorum string `protobuf:"bytes,18,opt,name=law_quorum,json=lawQuorum,proto3" json:"law_quorum,omitempty"` // Deprecated: Do not use.
	// Minimum proportion of Yes votes for a Law proposal to pass. Default value: 0.9.
	LawThreshold string `protobuf:"bytes,19,opt,name=law_threshold,json=lawThreshold,proto3" json:"law_threshold,omitempty"`
	// Duration of time after a proposal enters the voting period, during which quorum
	// must be achieved to not incur in a voting period extension.
	QuorumTimeout *time.Duration `protobuf:"bytes,20,opt,name=quorum_timeout,json=quorumTimeout,proto3,stdduration" json:"quorum_timeout,omitempty"`
	// Duration that expresses the maximum amount of time by which a proposal voting period
	// can be extended.
	MaxVotingPeriodExtension *time.Duration `protobuf:"bytes,21,opt,name=max_voting_period_extension,json=maxVotingPeriodExtension,proto3,stdduration" json:"max_voting_period_extension,omitempty"`
	// Number of times a proposal should be checked for quorum after the quorum timeout
	// has elapsed. Used to compute the amount of time in between quorum checks.
	QuorumCheckCount           uint64                      `protobuf:"varint,22,opt,name=quorum_check_count,json=quorumCheckCount,proto3" json:"quorum_check_count,omitempty"`
	MinDepositThrottler        *MinDepositThrottler        `protobuf:"bytes,23,opt,name=min_deposit_throttler,json=minDepositThrottler,proto3" json:"min_deposit_throttler,omitempty"`
	MinInitialDepositThrottler *MinInitialDepositThrottler `protobuf:"bytes,24,opt,name=min_initial_deposit_throttler,json=minInitialDepositThrottler,proto3" json:"min_initial_deposit_throttler,omitempty"`
	// Minimum proportion of No Votes for a proposal deposit to be burnt.
	BurnDepositNoThreshold string `protobuf:"bytes,25,opt,name=burn_deposit_no_threshold,json=burnDepositNoThreshold,proto3" json:"burn_deposit_no_threshold,omitempty"`
	// Achievable quorum
	QuorumRange *QuorumRange `protobuf:"bytes,26,opt,name=quorum_range,json=quorumRange,proto3" json:"quorum_range,omitempty"`
	// Achievable quorum for constitution amendment proposals
	ConstitutionAmendmentQuorumRange *QuorumRange `protobuf:"bytes,27,opt,name=constitution_amendment_quorum_range,json=constitutionAmendmentQuorumRange,proto3" json:"constitution_amendment_quorum_range,omitempty"`
	// Achievable quorum for law proposals
	LawQuorumRange *QuorumRange `protobuf:"bytes,28,opt,name=law_quorum_range,json=lawQuorumRange,proto3" json:"law_quorum_range,omitempty"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_ecf0f9950ff6986c, []int{12}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *Params) GetMinDeposit() []types.Coin {
	if m != nil {
		return m.MinDeposit
	}
	return nil
}

func (m *Params) GetMaxDepositPeriod() *time.Duration {
	if m != nil {
		return m.MaxDepositPeriod
	}
	return nil
}

func (m *Params) GetVotingPeriod() *time.Duration {
	if m != nil {
		return m.VotingPeriod
	}
	return nil
}

// Deprecated: Do not use.
func (m *Params) GetQuorum() string {
	if m != nil {
		return m.Quorum
	}
	return ""
}

func (m *Params) GetThreshold() string {
	if m != nil {
		return m.Threshold
	}
	return ""
}

// Deprecated: Do not use.
func (m *Params) GetMinInitialDepositRatio() string {
	if m != nil {
		return m.MinInitialDepositRatio
	}
	return ""
}

func (m *Params) GetBurnVoteQuorum() bool {
	if m != nil {
		return m.BurnVoteQuorum
	}
	return false
}

func (m *Params) GetBurnProposalDepositPrevote() bool {
	if m != nil {
		return m.BurnProposalDepositPrevote
	}
	return false
}

func (m *Params) GetMinDepositRatio() string {
	if m != nil {
		return m.MinDepositRatio
	}
	return ""
}

// Deprecated: Do not use.
func (m *Params) GetConstitutionAmendmentQuorum() string {
	if m != nil {
		return m.ConstitutionAmendmentQuorum
	}
	return ""
}

func (m *Params) GetConstitutionAmendmentThreshold() string {
	if m != nil {
		return m.ConstitutionAmendmentThreshold
	}
	return ""
}

// Deprecated: Do not use.
func (m *Params) GetLawQuorum() string {
	if m != nil {
		return m.LawQuorum
	}
	return ""
}

func (m *Params) GetLawThreshold() string {
	if m != nil {
		return m.LawThreshold
	}
	return ""
}

func (m *Params) GetQuorumTimeout() *time.Duration {
	if m != nil {
		return m.QuorumTimeout
	}
	return nil
}

func (m *Params) GetMaxVotingPeriodExtension() *time.Duration {
	if m != nil {
		return m.MaxVotingPeriodExtension
	}
	return nil
}

func (m *Params) GetQuorumCheckCount() uint64 {
	if m != nil {
		return m.QuorumCheckCount
	}
	return 0
}

func (m *Params) GetMinDepositThrottler() *MinDepositThrottler {
	if m != nil {
		return m.MinDepositThrottler
	}
	return nil
}

func (m *Params) GetMinInitialDepositThrottler() *MinInitialDepositThrottler {
	if m != nil {
		return m.MinInitialDepositThrottler
	}
	return nil
}

func (m *Params) GetBurnDepositNoThreshold() string {
	if m != nil {
		return m.BurnDepositNoThreshold
	}
	return ""
}

func (m *Params) GetQuorumRange() *QuorumRange {
	if m != nil {
		return m.QuorumRange
	}
	return nil
}

func (m *Params) GetConstitutionAmendmentQuorumRange() *QuorumRange {
	if m != nil {
		return m.ConstitutionAmendmentQuorumRange
	}
	return nil
}

func (m *Params) GetLawQuorumRange() *QuorumRange {
	if m != nil {
		return m.LawQuorumRange
	}
	return nil
}

type QuorumRange struct {
	// Maximum achievable quorum
	Max string `protobuf:"bytes,1,opt,name=max,proto3" json:"max,omitempty"`
	// Minimum achievable quorum
	Min string `protobuf:"bytes,2,opt,name=min,proto3" json:"min,omitempty"`
}

func (m *QuorumRange) Reset()         { *m = QuorumRange{} }
func (m *QuorumRange) String() string { return proto.CompactTextString(m) }
func (*QuorumRange) ProtoMessage()    {}
func (*QuorumRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_ecf0f9950ff6986c, []int{13}
}
func (m *QuorumRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuorumRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuorumRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuorumRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuorumRange.Merge(m, src)
}
func (m *QuorumRange) XXX_Size() int {
	return m.Size()
}
func (m *QuorumRange) XXX_DiscardUnknown() {
	xxx_messageInfo_QuorumRange.DiscardUnknown(m)
}

var xxx_messageInfo_QuorumRange proto.InternalMessageInfo

func (m *QuorumRange) GetMax() string {
	if m != nil {
		return m.Max
	}
	return ""
}

func (m *QuorumRange) GetMin() string {
	if m != nil {
		return m.Min
	}
	return ""
}

func init() {
	proto.RegisterEnum("atomone.gov.v1.VoteOption", VoteOption_name, VoteOption_value)
	proto.RegisterEnum("atomone.gov.v1.ProposalStatus", ProposalStatus_name, ProposalStatus_value)
	proto.RegisterType((*WeightedVoteOption)(nil), "atomone.gov.v1.WeightedVoteOption")
	proto.RegisterType((*Deposit)(nil), "atomone.gov.v1.Deposit")
	proto.RegisterType((*LastMinDeposit)(nil), "atomone.gov.v1.LastMinDeposit")
	proto.RegisterType((*Proposal)(nil), "atomone.gov.v1.Proposal")
	proto.RegisterType((*TallyResult)(nil), "atomone.gov.v1.TallyResult")
	proto.RegisterType((*Vote)(nil), "atomone.gov.v1.Vote")
	proto.RegisterType((*QuorumCheckQueueEntry)(nil), "atomone.gov.v1.QuorumCheckQueueEntry")
	proto.RegisterType((*DepositParams)(nil), "atomone.gov.v1.DepositParams")
	proto.RegisterType((*VotingParams)(nil), "atomone.gov.v1.VotingParams")
	proto.RegisterType((*TallyParams)(nil), "atomone.gov.v1.TallyParams")
	proto.RegisterType((*MinDepositThrottler)(nil), "atomone.gov.v1.MinDepositThrottler")
	proto.RegisterType((*MinInitialDepositThrottler)(nil), "atomone.gov.v1.MinInitialDepositThrottler")
	proto.RegisterType((*Params)(nil), "atomone.gov.v1.Params")
	proto.RegisterType((*QuorumRange)(nil), "atomone.gov.v1.QuorumRange")
}

func init() { proto.RegisterFile("atomone/gov/v1/gov.proto", fileDescriptor_ecf0f9950ff6986c) }

var fileDescriptor_ecf0f9950ff6986c = []byte{
	// 1874 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x58, 0xbd, 0x6f, 0x1b, 0xc9,
	0x15, 0xd7, 0x8a, 0x14, 0x25, 0x3d, 0x8a, 0xd4, 0x6a, 0x24, 0xdb, 0x2b, 0xca, 0xa2, 0x74, 0xbc,
	0x43, 0xa0, 0x73, 0x6c, 0x32, 0xb2, 0x2f, 0x2e, 0x0e, 0x07, 0x04, 0x94, 0x48, 0x3b, 0x74, 0x6c,
	0x91, 0x5e, 0xd2, 0xba, 0x5c, 0x8a, 0x2c, 0x46, 0xdc, 0x31, 0xb5, 0x38, 0xee, 0x0c, 0xbd, 0x3b,
	0xa4, 0xc5, 0x94, 0xf9, 0x0b, 0x0e, 0x48, 0x93, 0xa4, 0x4a, 0x99, 0x32, 0xc5, 0x01, 0x69, 0xd3,
	0x04, 0xb8, 0xf2, 0x70, 0x45, 0x90, 0x34, 0x4e, 0x60, 0x17, 0x01, 0xfc, 0x2f, 0xa4, 0x09, 0xe6,
	0x63, 0xf9, 0x25, 0xd2, 0x92, 0x8c, 0x04, 0x08, 0xd2, 0x48, 0xbb, 0xf3, 0x7e, 0xbf, 0xf7, 0xde,
	0xcc, 0xfb, 0x98, 0xc7, 0x05, 0x0b, 0x73, 0xe6, 0x33, 0x4a, 0x0a, 0x2d, 0xd6, 0x2b, 0xf4, 0xf6,
	0xc5, 0xbf, 0x7c, 0x27, 0x60, 0x9c, 0xa1, 0xb4, 0x96, 0xe4, 0xc5, 0x52, 0x6f, 0x3f, 0x93, 0x6d,
	0xb2, 0xd0, 0x67, 0x61, 0xe1, 0x04, 0x87, 0xa4, 0xd0, 0xdb, 0x3f, 0x21, 0x1c, 0xef, 0x17, 0x9a,
	0xcc, 0xa3, 0x0a, 0x9f, 0xd9, 0x68, 0xb1, 0x16, 0x93, 0x8f, 0x05, 0xf1, 0xa4, 0x57, 0x77, 0x5a,
	0x8c, 0xb5, 0xda, 0xa4, 0x20, 0xdf, 0x4e, 0xba, 0xcf, 0x0b, 0xdc, 0xf3, 0x49, 0xc8, 0xb1, 0xdf,
	0xd1, 0x80, 0xcd, 0x49, 0x00, 0xa6, 0x7d, 0x2d, 0xca, 0x4e, 0x8a, 0xdc, 0x6e, 0x80, 0xb9, 0xc7,
	0x22, 0x8b, 0x9b, 0xca, 0x23, 0x47, 0x19, 0x55, 0x2f, 0x5a, 0xb4, 0x86, 0x7d, 0x8f, 0xb2, 0x82,
	0xfc, 0xab, 0x96, 0x72, 0x1d, 0x40, 0x9f, 0x13, 0xaf, 0x75, 0xca, 0x89, 0x7b, 0xcc, 0x38, 0xa9,
	0x76, 0x84, 0x26, 0x74, 0x17, 0x12, 0x4c, 0x3e, 0x59, 0xc6, 0xae, 0xb1, 0x97, 0xbe, 0x9b, 0xc9,
	0x8f, 0x6f, 0x3b, 0x3f, 0xc4, 0xda, 0x1a, 0x89, 0xbe, 0x07, 0x89, 0x97, 0x52, 0x93, 0x35, 0xbf,
	0x6b, 0xec, 0x2d, 0x1f, 0xa4, 0xbf, 0xfb, 0xfa, 0x0e, 0x68, 0xf3, 0x25, 0xd2, 0xb4, 0xb5, 0x34,
	0xf7, 0x3b, 0x03, 0x16, 0x4b, 0xa4, 0xc3, 0x42, 0x8f, 0xa3, 0x1d, 0x48, 0x76, 0x02, 0xd6, 0x61,
	0x21, 0x6e, 0x3b, 0x9e, 0x2b, 0x8d, 0xc5, 0x6d, 0x88, 0x96, 0x2a, 0x2e, 0xba, 0x0f, 0xcb, 0xae,
	0xc2, 0xb2, 0x40, 0xeb, 0xb5, 0xbe, 0xfb, 0xfa, 0xce, 0x86, 0xd6, 0x5b, 0x74, 0xdd, 0x80, 0x84,
	0x61, 0x9d, 0x07, 0x1e, 0x6d, 0xd9, 0x43, 0x28, 0xfa, 0x0c, 0x12, 0xd8, 0x67, 0x5d, 0xca, 0xad,
	0xd8, 0x6e, 0x6c, 0x2f, 0x79, 0x77, 0x33, 0xaf, 0x19, 0x22, 0x4e, 0x79, 0x1d, 0xa7, 0xfc, 0x21,
	0xf3, 0xe8, 0xc1, 0xf2, 0x37, 0xaf, 0x76, 0xe6, 0x7e, 0xff, 0xcf, 0x3f, 0xdc, 0x32, 0x6c, 0xcd,
	0xc9, 0xfd, 0xd2, 0x80, 0xf4, 0x63, 0x1c, 0xf2, 0x27, 0x1e, 0x8d, 0x3c, 0xfd, 0x14, 0x16, 0x7a,
	0xb8, 0xdd, 0x25, 0x96, 0x71, 0x05, 0x7d, 0x8a, 0x82, 0x3e, 0x81, 0xb8, 0x88, 0xaf, 0xf4, 0x3f,
	0x79, 0x37, 0x93, 0x57, 0x01, 0xcc, 0x47, 0x01, 0xcc, 0x37, 0xa2, 0xe0, 0x1f, 0xc4, 0xbf, 0xfa,
	0xfb, 0x8e, 0x61, 0x4b, 0x74, 0xee, 0x4f, 0x09, 0x58, 0xaa, 0xe9, 0x93, 0x40, 0x69, 0x98, 0x1f,
	0x9c, 0xcf, 0xbc, 0xe7, 0xa2, 0x1f, 0xc0, 0x92, 0x4f, 0xc2, 0x10, 0xb7, 0x48, 0x68, 0xcd, 0x4b,
	0x8f, 0x36, 0xce, 0xa9, 0x2d, 0xd2, 0xbe, 0x3d, 0x40, 0xa1, 0xfb, 0x90, 0x08, 0x39, 0xe6, 0xdd,
	0xd0, 0x8a, 0xc9, 0x90, 0x66, 0x27, 0x43, 0x1a, 0xd9, 0xaa, 0x4b, 0x94, 0xad, 0xd1, 0xa8, 0x02,
	0xe8, 0xb9, 0x47, 0x71, 0xdb, 0xe1, 0xb8, 0xdd, 0xee, 0x3b, 0x01, 0x09, 0xbb, 0x6d, 0x6e, 0xc5,
	0xe5, 0x56, 0xb6, 0x26, 0x75, 0x34, 0x04, 0xc6, 0x96, 0x10, 0xdb, 0x94, 0xb4, 0x91, 0x15, 0x54,
	0x84, 0x64, 0xd8, 0x3d, 0xf1, 0x3d, 0xee, 0xc8, 0xe3, 0x58, 0xb8, 0xe4, 0x71, 0x80, 0x22, 0x89,
	0x65, 0xf4, 0x08, 0x4c, 0x1d, 0x64, 0x87, 0x50, 0x57, 0xe9, 0x49, 0x5c, 0x52, 0x4f, 0x5a, 0x33,
	0xcb, 0xd4, 0x95, 0xba, 0x2a, 0x90, 0xe2, 0x8c, 0xe3, 0xb6, 0xa3, 0xd7, 0xad, 0xc5, 0x2b, 0x84,
	0x76, 0x45, 0x52, 0xa3, 0xec, 0x78, 0x0c, 0x6b, 0x3d, 0xc6, 0x3d, 0xda, 0x72, 0x42, 0x8e, 0x03,
	0xbd, 0xbf, 0xa5, 0x4b, 0xfa, 0xb5, 0xaa, 0xa8, 0x75, 0xc1, 0x94, 0x8e, 0xfd, 0x18, 0xf4, 0xd2,
	0x70, 0x8f, 0xcb, 0x97, 0xd4, 0x95, 0x52, 0xc4, 0x68, 0x8b, 0x19, 0x91, 0x26, 0x1c, 0xbb, 0x98,
	0x63, 0x0b, 0x44, 0xf5, 0xd8, 0x83, 0x77, 0xb4, 0x01, 0x0b, 0xdc, 0xe3, 0x6d, 0x62, 0x25, 0xa5,
	0x40, 0xbd, 0x20, 0x0b, 0x16, 0xc3, 0xae, 0xef, 0xe3, 0xa0, 0x6f, 0xad, 0xc8, 0xf5, 0xe8, 0x15,
	0x7d, 0x02, 0x4b, 0xaa, 0x30, 0x49, 0x60, 0xa5, 0x2e, 0xa8, 0xc4, 0x01, 0x52, 0x78, 0x40, 0xa8,
	0xcb, 0x82, 0x90, 0xb8, 0x56, 0x7a, 0xd7, 0xd8, 0x5b, 0xb2, 0x07, 0xef, 0x28, 0x0b, 0x80, 0x29,
	0x65, 0x5c, 0x76, 0x2f, 0x6b, 0x55, 0x9a, 0x1b, 0x59, 0x41, 0x3f, 0x82, 0x9b, 0xb2, 0x2f, 0x3a,
	0xfa, 0x34, 0x3a, 0x24, 0xf0, 0x98, 0xeb, 0x90, 0x33, 0x4e, 0xa8, 0x4b, 0x5c, 0xcb, 0xdc, 0x35,
	0xf6, 0x52, 0xf6, 0xa6, 0xc4, 0x1c, 0x4b, 0x48, 0x4d, 0x22, 0xca, 0x1a, 0x90, 0xfb, 0xad, 0x01,
	0xc9, 0xd1, 0x04, 0xfc, 0x3e, 0x2c, 0xf7, 0x49, 0xe8, 0x34, 0x65, 0x63, 0x30, 0xce, 0x75, 0xa9,
	0x0a, 0xe5, 0xf6, 0x52, 0x9f, 0x84, 0x87, 0x42, 0x8e, 0xee, 0x41, 0x0a, 0x9f, 0x84, 0x1c, 0x7b,
	0x54, 0x13, 0xe6, 0xa7, 0x12, 0x56, 0x34, 0x48, 0x91, 0x3e, 0x86, 0x25, 0xca, 0x34, 0x3e, 0x36,
	0x15, 0xbf, 0x48, 0x99, 0x84, 0xe6, 0xfe, 0x68, 0x40, 0x5c, 0xb4, 0xd1, 0x8b, 0x9b, 0x60, 0x1e,
	0x16, 0x7a, 0x8c, 0x93, 0x8b, 0x1b, 0xa0, 0x82, 0xa1, 0xcf, 0x60, 0x51, 0xf5, 0xe4, 0xd0, 0x8a,
	0xcb, 0x94, 0xce, 0x4d, 0xd6, 0xe9, 0xf9, 0x96, 0x6f, 0x47, 0x94, 0xb1, 0x9c, 0x59, 0x18, 0xcf,
	0x99, 0x47, 0xf1, 0xa5, 0x98, 0x19, 0xcf, 0xfd, 0xd9, 0x80, 0x6b, 0x4f, 0xbb, 0x2c, 0xe8, 0xfa,
	0x87, 0xa7, 0xa4, 0xf9, 0xe5, 0xd3, 0x2e, 0xe9, 0x92, 0x32, 0xe5, 0x41, 0x1f, 0xd5, 0x60, 0xfd,
	0x85, 0x14, 0xc8, 0xac, 0x65, 0x5d, 0x5d, 0x09, 0xc6, 0x25, 0xb3, 0x77, 0x4d, 0x91, 0x1b, 0x8a,
	0x2b, 0x33, 0xf8, 0x36, 0x20, 0xad, 0xb1, 0x29, 0x6c, 0x8d, 0x84, 0x22, 0x6e, 0x9b, 0x2f, 0x86,
	0x4e, 0xa8, 0xe3, 0x9f, 0x40, 0x87, 0x8e, 0xcb, 0x28, 0x91, 0x81, 0x18, 0x47, 0x87, 0x25, 0x46,
	0x49, 0xee, 0x6f, 0x06, 0xa4, 0x74, 0x05, 0xd7, 0x70, 0x80, 0xfd, 0x10, 0x7d, 0x01, 0x49, 0xdf,
	0xa3, 0x83, 0x86, 0x70, 0x61, 0xaf, 0xdf, 0x16, 0x0d, 0xe1, 0xed, 0xab, 0x9d, 0x6b, 0x23, 0xac,
	0xdb, 0xcc, 0xf7, 0x38, 0xf1, 0x3b, 0xbc, 0x6f, 0x83, 0x3f, 0xbc, 0x40, 0x7c, 0x40, 0x3e, 0x3e,
	0x8b, 0x40, 0x3a, 0x97, 0xf5, 0x95, 0xb0, 0x79, 0xee, 0x64, 0x4a, 0xfa, 0x4e, 0x3f, 0xf8, 0xe8,
	0xed, 0xab, 0x9d, 0x9b, 0xe7, 0x89, 0x43, 0x23, 0xbf, 0x16, 0x07, 0x67, 0xfa, 0xf8, 0x2c, 0xda,
	0x89, 0x94, 0xe7, 0x1a, 0xb0, 0xa2, 0x4b, 0x42, 0xed, 0xac, 0x04, 0xa9, 0xb1, 0x2a, 0xd2, 0x31,
	0x79, 0x87, 0xe5, 0xb8, 0xd4, 0xbc, 0xd2, 0x1b, 0x29, 0xac, 0xdc, 0xbf, 0xe6, 0x75, 0x41, 0x69,
	0xad, 0x7b, 0x90, 0x50, 0xa7, 0xaa, 0xab, 0xc9, 0x1c, 0xbf, 0xf3, 0x2d, 0xc3, 0xd6, 0x72, 0x74,
	0x1b, 0x96, 0xf9, 0x69, 0x40, 0xc2, 0x53, 0xd6, 0x76, 0x67, 0x0c, 0x08, 0x43, 0x00, 0x6a, 0xc0,
	0x76, 0x93, 0xd1, 0x90, 0x7b, 0xbc, 0x2b, 0x7c, 0x71, 0xb0, 0x4f, 0xa8, 0xeb, 0x13, 0xca, 0x1d,
	0x6d, 0x2e, 0x36, 0xc3, 0xdc, 0xd6, 0x28, 0xad, 0x18, 0xb1, 0x54, 0xb2, 0xa2, 0x9f, 0xc2, 0xee,
	0x0c, 0xad, 0x43, 0xd7, 0xe2, 0x53, 0x5d, 0xcb, 0x4e, 0x55, 0xdb, 0x18, 0xf8, 0x5b, 0x00, 0x68,
	0xe3, 0x97, 0x91, 0x73, 0x0b, 0x33, 0x9c, 0x5b, 0x6e, 0xe3, 0x97, 0xda, 0x95, 0x7b, 0x90, 0x12,
	0x84, 0xa1, 0xdd, 0xc4, 0x54, 0xbb, 0x2b, 0x6d, 0xfc, 0x72, 0x60, 0x25, 0xf7, 0x9b, 0x18, 0xac,
	0x0f, 0x47, 0x92, 0xc6, 0x69, 0xc0, 0x38, 0x6f, 0x93, 0x00, 0x95, 0x21, 0xf9, 0xbc, 0xcd, 0x58,
	0xe0, 0x5c, 0x7d, 0x42, 0x01, 0x49, 0x3c, 0x96, 0x63, 0x4a, 0x09, 0x52, 0xdd, 0x8e, 0x8b, 0x39,
	0xb9, 0x74, 0x72, 0xea, 0x14, 0x51, 0x2c, 0x95, 0x22, 0xe8, 0x3e, 0xdc, 0xe0, 0x38, 0x68, 0x11,
	0xee, 0xe0, 0x26, 0xf7, 0x7a, 0xc4, 0x89, 0x1a, 0x59, 0xa8, 0xeb, 0xf0, 0x9a, 0x12, 0x17, 0xa5,
	0x34, 0x1a, 0x3a, 0x42, 0xf4, 0x43, 0x48, 0x7b, 0xb4, 0x19, 0x10, 0x1c, 0x12, 0x47, 0xaa, 0x9f,
	0x11, 0x8a, 0x54, 0x84, 0xb2, 0x05, 0x48, 0xd0, 0x5c, 0x32, 0x46, 0x5b, 0x98, 0x4e, 0x8b, 0x50,
	0x8a, 0x56, 0x85, 0x8f, 0x06, 0xb4, 0x90, 0xd0, 0xd0, 0xe3, 0x5e, 0xcf, 0xe3, 0x7d, 0x47, 0xbb,
	0xee, 0x7a, 0x21, 0xc7, 0xb4, 0xa9, 0x66, 0x8b, 0xb8, 0xfd, 0x41, 0x84, 0xad, 0x0f, 0xa1, 0x0d,
	0x89, 0x2c, 0x69, 0x60, 0xee, 0x57, 0x31, 0xc8, 0x3c, 0xf1, 0x68, 0x85, 0x7a, 0xdc, 0x1b, 0xcc,
	0x05, 0xff, 0xa3, 0x21, 0xfa, 0x18, 0x4c, 0xbd, 0xcf, 0xc9, 0xd8, 0xac, 0xaa, 0xf5, 0xff, 0x9b,
	0xa8, 0xfc, 0x65, 0x05, 0x12, 0xba, 0x55, 0x3d, 0xbc, 0x62, 0x6b, 0x4f, 0x0e, 0x22, 0x60, 0x19,
	0x63, 0x8d, 0xfc, 0xc9, 0xfb, 0x35, 0xf2, 0xf8, 0xf4, 0x46, 0x7d, 0xbe, 0x31, 0xc7, 0xde, 0xa3,
	0x31, 0x8f, 0x34, 0xe2, 0xf8, 0x55, 0x1a, 0xf1, 0xc2, 0x45, 0x8d, 0xf8, 0x27, 0xb0, 0x29, 0x4e,
	0xcd, 0x53, 0x69, 0x3d, 0xd8, 0xb4, 0x8a, 0xe9, 0xe2, 0x0c, 0x53, 0xd7, 0xfd, 0xc9, 0x42, 0x50,
	0xe1, 0xdd, 0x03, 0xf3, 0xa4, 0x1b, 0x50, 0x31, 0xce, 0x91, 0xa8, 0x57, 0xa6, 0xe4, 0x4c, 0x98,
	0x16, 0xeb, 0x62, 0x18, 0xd1, 0xed, 0xb1, 0x08, 0xdb, 0x12, 0x39, 0x98, 0x8b, 0x06, 0xa7, 0x1d,
	0x10, 0xc1, 0xd6, 0xa3, 0x64, 0x46, 0x80, 0xa2, 0x64, 0x8d, 0x8e, 0x55, 0x21, 0xd0, 0xa7, 0xb0,
	0x36, 0x12, 0x6f, 0xed, 0xf1, 0xea, 0xd4, 0xfd, 0xae, 0x0e, 0xa3, 0xab, 0x1c, 0xbd, 0xf0, 0xfa,
	0x31, 0xff, 0x5b, 0xd7, 0xcf, 0xda, 0x7f, 0xe0, 0xfa, 0x41, 0xef, 0x71, 0xfd, 0xac, 0x5f, 0x7c,
	0xfd, 0xa0, 0x07, 0x90, 0x1e, 0x1f, 0xee, 0xac, 0x8d, 0xcb, 0xa5, 0x6a, 0x6a, 0x6c, 0xac, 0x43,
	0x3f, 0x87, 0x2d, 0x51, 0x40, 0x53, 0x86, 0xfa, 0x50, 0xfc, 0x0e, 0xb8, 0x76, 0x39, 0xa5, 0x96,
	0x8f, 0xcf, 0xce, 0x0d, 0xfd, 0x42, 0xc1, 0x8c, 0x91, 0xf1, 0xfa, 0x8c, 0x91, 0xf1, 0x73, 0x18,
	0x1d, 0xde, 0xc4, 0x91, 0xa8, 0x96, 0x6d, 0xdd, 0x90, 0x7e, 0x7c, 0x38, 0x39, 0x3a, 0x4f, 0xb9,
	0x80, 0xed, 0x75, 0x7f, 0xca, 0xad, 0xec, 0xc3, 0xf6, 0xb4, 0xd2, 0x19, 0x1a, 0xb0, 0xa4, 0x81,
	0x5b, 0x53, 0x0c, 0xcc, 0xb8, 0x45, 0xec, 0x8c, 0x3f, 0xfb, 0x86, 0xa9, 0xc0, 0xa6, 0x2c, 0x99,
	0xc8, 0x0e, 0x65, 0x23, 0xe1, 0xdd, 0x9c, 0x1a, 0xde, 0xeb, 0x82, 0xa0, 0x15, 0x1d, 0xb1, 0x61,
	0xa0, 0x8f, 0x60, 0x45, 0x1f, 0x60, 0x80, 0x69, 0x8b, 0x58, 0x99, 0xe9, 0x3f, 0xf6, 0x55, 0x2e,
	0xd9, 0x02, 0x72, 0x4e, 0x75, 0xf2, 0xc5, 0x50, 0x88, 0x7e, 0x01, 0x1f, 0xbe, 0xb3, 0x9c, 0xb4,
	0x99, 0xad, 0xab, 0x9b, 0xd9, 0x7d, 0x47, 0xbd, 0x29, 0xdb, 0xcf, 0xc0, 0x1c, 0x96, 0x86, 0x36,
	0x74, 0xf3, 0xea, 0x86, 0xd2, 0x83, 0xda, 0x91, 0xf2, 0xdc, 0x53, 0x48, 0x8e, 0x5a, 0xd9, 0x85,
	0x98, 0x8f, 0xcf, 0xa6, 0xfc, 0xa4, 0x14, 0x5c, 0x21, 0x92, 0x08, 0x8f, 0xce, 0x98, 0x7c, 0x85,
	0xe8, 0xd6, 0x97, 0x00, 0x23, 0x5f, 0xe0, 0xb6, 0xe0, 0xc6, 0x71, 0xb5, 0x51, 0x76, 0xaa, 0xb5,
	0x46, 0xa5, 0x7a, 0xe4, 0x3c, 0x3b, 0xaa, 0xd7, 0xca, 0x87, 0x95, 0x07, 0x95, 0x72, 0xc9, 0x9c,
	0x43, 0xeb, 0xb0, 0x3a, 0x2a, 0xfc, 0xa2, 0x5c, 0x37, 0x0d, 0x74, 0x03, 0xd6, 0x47, 0x17, 0x8b,
	0x07, 0xf5, 0x46, 0xb1, 0x72, 0x64, 0xce, 0x23, 0x04, 0xe9, 0x51, 0xc1, 0x51, 0xd5, 0x8c, 0xdd,
	0x7a, 0x6b, 0x40, 0x7a, 0xfc, 0x83, 0x0f, 0xda, 0x81, 0xad, 0x9a, 0x5d, 0xad, 0x55, 0xeb, 0xc5,
	0xc7, 0x4e, 0xbd, 0x51, 0x6c, 0x3c, 0xab, 0x4f, 0x58, 0xcd, 0x41, 0x76, 0x12, 0x50, 0x2a, 0xd7,
	0xaa, 0xf5, 0x4a, 0xc3, 0xa9, 0x95, 0xed, 0x4a, 0xb5, 0x64, 0x1a, 0xe8, 0x03, 0xd8, 0x9e, 0xc4,
	0x1c, 0x57, 0x1b, 0x95, 0xa3, 0x87, 0x11, 0x64, 0x1e, 0x65, 0xe0, 0xfa, 0x24, 0xa4, 0x56, 0xac,
	0xd7, 0xcb, 0x25, 0x33, 0x86, 0x6e, 0x82, 0x35, 0x29, 0xb3, 0xcb, 0x8f, 0xca, 0x87, 0x8d, 0x72,
	0xc9, 0x8c, 0x4f, 0x63, 0x3e, 0x28, 0x56, 0x1e, 0x97, 0x4b, 0xe6, 0xc2, 0x34, 0xd9, 0x71, 0xb9,
	0x51, 0x2d, 0x97, 0xcc, 0xc4, 0xc1, 0xc3, 0x6f, 0x5e, 0x67, 0x8d, 0x6f, 0x5f, 0x67, 0x8d, 0x7f,
	0xbc, 0xce, 0x1a, 0x5f, 0xbd, 0xc9, 0xce, 0x7d, 0xfb, 0x26, 0x3b, 0xf7, 0xd7, 0x37, 0xd9, 0xb9,
	0x9f, 0xdd, 0x69, 0x79, 0xfc, 0xb4, 0x7b, 0x92, 0x6f, 0x32, 0xbf, 0xa0, 0xb3, 0xe1, 0xce, 0x69,
	0xf7, 0x24, 0x7a, 0x2e, 0x9c, 0xc9, 0x0f, 0xc0, 0xbc, 0xdf, 0x21, 0x61, 0xa1, 0xb7, 0x7f, 0x92,
	0x90, 0xcd, 0xe8, 0xde, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0xca, 0x30, 0xd0, 0xe5, 0x1f, 0x16,
	0x00, 0x00,
}

func (m *WeightedVoteOption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WeightedVoteOption) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WeightedVoteOption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Weight) > 0 {
		i -= len(m.Weight)
		copy(dAtA[i:], m.Weight)
		i = encodeVarintGov(dAtA, i, uint64(len(m.Weight)))
		i--
		dAtA[i] = 0x12
	}
	if m.Option != 0 {
		i = encodeVarintGov(dAtA, i, uint64(m.Option))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Deposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Deposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGov(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Depositor) > 0 {
		i -= len(m.Depositor)
		copy(dAtA[i:], m.Depositor)
		i = encodeVarintGov(dAtA, i, uint64(len(m.Depositor)))
		i--
		dAtA[i] = 0x12
	}
	if m.ProposalId != 0 {
		i = encodeVarintGov(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LastMinDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LastMinDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LastMinDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != nil {
		n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.Time, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.Time):])
		if err1 != nil {
			return 0, err1
		}
		i -= n1
		i = encodeVarintGov(dAtA, i, uint64(n1))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Value) > 0 {
		for iNdEx := len(m.Value) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Value[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGov(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Proposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Proposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TimesVotingPeriodExtended != 0 {
		i = encodeVarintGov(dAtA, i, uint64(m.TimesVotingPeriodExtended))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.Annotation) > 0 {
		i -= len(m.Annotation)
		copy(dAtA[i:], m.Annotation)
		i = encodeVarintGov(dAtA, i, uint64(len(m.Annotation)))
		i--
		dAtA[i] = 0x7a
	}
	if m.Endorsed {
		i--
		if m.Endorsed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if len(m.Proposer) > 0 {
		i -= len(m.Proposer)
		copy(dAtA[i:], m.Proposer)
		i = encodeVarintGov(dAtA, i, uint64(len(m.Proposer)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Summary) > 0 {
		i -= len(m.Summary)
		copy(dAtA[i:], m.Summary)
		i = encodeVarintGov(dAtA, i, uint64(len(m.Summary)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintGov(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintGov(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x52
	}
	if m.VotingEndTime != nil {
		n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.VotingEndTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.VotingEndTime):])
		if err2 != nil {
			return 0, err2
		}
		i -= n2
		i = encodeVarintGov(dAtA, i, uint64(n2))
		i--
		dAtA[i] = 0x4a
	}
	if m.VotingStartTime != nil {
		n3, err3 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.VotingStartTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.VotingStartTime):])
		if err3 != nil {
			return 0, err3
		}
		i -= n3
		i = encodeVarintGov(dAtA, i, uint64(n3))
		i--
		dAtA[i] = 0x42
	}
	if len(m.TotalDeposit) > 0 {
		for iNdEx := len(m.TotalDeposit) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TotalDeposit[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGov(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.DepositEndTime != nil {
		n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.DepositEndTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.DepositEndTime):])
		if err4 != nil {
			return 0, err4
		}
		i -= n4
		i = encodeVarintGov(dAtA, i, uint64(n4))
		i--
		dAtA[i] = 0x32
	}
	if m.SubmitTime != nil {
		n5, err5 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.SubmitTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.SubmitTime):])
		if err5 != nil {
			return 0, err5
		}
		i -= n5
		i = encodeVarintGov(dAtA, i, uint64(n5))
		i--
		dAtA[i] = 0x2a
	}
	if m.FinalTallyResult != nil {
		{
			size, err := m.FinalTallyResult.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGov(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Status != 0 {
		i = encodeVarintGov(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Messages) > 0 {
		for iNdEx := len(m.Messages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Messages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGov(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Id != 0 {
		i = encodeVarintGov(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TallyResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TallyResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TallyResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NoCount) > 0 {
		i -= len(m.NoCount)
		copy(dAtA[i:], m.NoCount)
		i = encodeVarintGov(dAtA, i, uint64(len(m.NoCount)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AbstainCount) > 0 {
		i -= len(m.AbstainCount)
		copy(dAtA[i:], m.AbstainCount)
		i = encodeVarintGov(dAtA, i, uint64(len(m.AbstainCount)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.YesCount) > 0 {
		i -= len(m.YesCount)
		copy(dAtA[i:], m.YesCount)
		i = encodeVarintGov(dAtA, i, uint64(len(m.YesCount)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Vote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintGov(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Options) > 0 {
		for iNdEx := len(m.Options) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Options[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGov(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Voter) > 0 {
		i -= len(m.Voter)
		copy(dAtA[i:], m.Voter)
		i = encodeVarintGov(dAtA, i, uint64(len(m.Voter)))
		i--
		dAtA[i] = 0x12
	}
	if m.ProposalId != 0 {
		i = encodeVarintGov(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QuorumCheckQueueEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuorumCheckQueueEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuorumCheckQueueEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.QuorumChecksDone != 0 {
		i = encodeVarintGov(dAtA, i, uint64(m.QuorumChecksDone))
		i--
		dAtA[i] = 0x18
	}
	if m.QuorumCheckCount != 0 {
		i = encodeVarintGov(dAtA, i, uint64(m.QuorumCheckCount))
		i--
		dAtA[i] = 0x10
	}
	if m.QuorumTimeoutTime != nil {
		n7, err7 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.QuorumTimeoutTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.QuorumTimeoutTime):])
		if err7 != nil {
			return 0, err7
		}
		i -= n7
		i = encodeVarintGov(dAtA, i, uint64(n7))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DepositParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DepositParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DepositParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxDepositPeriod != nil {
		n8, err8 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(*m.MaxDepositPeriod, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.MaxDepositPeriod):])
		if err8 != nil {
			return 0, err8
		}
		i -= n8
		i = encodeVarintGov(dAtA, i, uint64(n8))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MinDeposit) > 0 {
		for iNdEx := len(m.MinDeposit) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MinDeposit[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGov(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *VotingParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VotingParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VotingParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VotingPeriod != nil {
		n9, err9 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(*m.VotingPeriod, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.VotingPeriod):])
		if err9 != nil {
			return 0, err9
		}
		i -= n9
		i = encodeVarintGov(dAtA, i, uint64(n9))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TallyParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TallyParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TallyParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LawThreshold) > 0 {
		i -= len(m.LawThreshold)
		copy(dAtA[i:], m.LawThreshold)
		i = encodeVarintGov(dAtA, i, uint64(len(m.LawThreshold)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.LawQuorum) > 0 {
		i -= len(m.LawQuorum)
		copy(dAtA[i:], m.LawQuorum)
		i = encodeVarintGov(dAtA, i, uint64(len(m.LawQuorum)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ConstitutionAmendmentThreshold) > 0 {
		i -= len(m.ConstitutionAmendmentThreshold)
		copy(dAtA[i:], m.ConstitutionAmendmentThreshold)
		i = encodeVarintGov(dAtA, i, uint64(len(m.ConstitutionAmendmentThreshold)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ConstitutionAmendmentQuorum) > 0 {
		i -= len(m.ConstitutionAmendmentQuorum)
		copy(dAtA[i:], m.ConstitutionAmendmentQuorum)
		i = encodeVarintGov(dAtA, i, uint64(len(m.ConstitutionAmendmentQuorum)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Threshold) > 0 {
		i -= len(m.Threshold)
		copy(dAtA[i:], m.Threshold)
		i = encodeVarintGov(dAtA, i, uint64(len(m.Threshold)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Quorum) > 0 {
		i -= len(m.Quorum)
		copy(dAtA[i:], m.Quorum)
		i = encodeVarintGov(dAtA, i, uint64(len(m.Quorum)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MinDepositThrottler) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MinDepositThrottler) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MinDepositThrottler) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DecreaseSensitivityTargetDistance != 0 {
		i = encodeVarintGov(dAtA, i, uint64(m.DecreaseSensitivityTargetDistance))
		i--
		dAtA[i] = 0x30
	}
	if len(m.DecreaseRatio) > 0 {
		i -= len(m.DecreaseRatio)
		copy(dAtA[i:], m.DecreaseRatio)
		i = encodeVarintGov(dAtA, i, uint64(len(m.DecreaseRatio)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.IncreaseRatio) > 0 {
		i -= len(m.IncreaseRatio)
		copy(dAtA[i:], m.IncreaseRatio)
		i = encodeVarintGov(dAtA, i, uint64(len(m.IncreaseRatio)))
		i--
		dAtA[i] = 0x22
	}
	if m.TargetActiveProposals != 0 {
		i = encodeVarintGov(dAtA, i, uint64(m.TargetActiveProposals))
		i--
		dAtA[i] = 0x18
	}
	if m.UpdatePeriod != nil {
		n10, err10 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(*m.UpdatePeriod, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.UpdatePeriod):])
		if err10 != nil {
			return 0, err10
		}
		i -= n10
		i = encodeVarintGov(dAtA, i, uint64(n10))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FloorValue) > 0 {
		for iNdEx := len(m.FloorValue) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FloorValue[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGov(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MinInitialDepositThrottler) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MinInitialDepositThrottler) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MinInitialDepositThrottler) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DecreaseSensitivityTargetDistance != 0 {
		i = encodeVarintGov(dAtA, i, uint64(m.DecreaseSensitivityTargetDistance))
		i--
		dAtA[i] = 0x30
	}
	if len(m.DecreaseRatio) > 0 {
		i -= len(m.DecreaseRatio)
		copy(dAtA[i:], m.DecreaseRatio)
		i = encodeVarintGov(dAtA, i, uint64(len(m.DecreaseRatio)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.IncreaseRatio) > 0 {
		i -= len(m.IncreaseRatio)
		copy(dAtA[i:], m.IncreaseRatio)
		i = encodeVarintGov(dAtA, i, uint64(len(m.IncreaseRatio)))
		i--
		dAtA[i] = 0x22
	}
	if m.TargetProposals != 0 {
		i = encodeVarintGov(dAtA, i, uint64(m.TargetProposals))
		i--
		dAtA[i] = 0x18
	}
	if m.UpdatePeriod != nil {
		n11, err11 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(*m.UpdatePeriod, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.UpdatePeriod):])
		if err11 != nil {
			return 0, err11
		}
		i -= n11
		i = encodeVarintGov(dAtA, i, uint64(n11))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FloorValue) > 0 {
		for iNdEx := len(m.FloorValue) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FloorValue[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGov(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LawQuorumRange != nil {
		{
			size, err := m.LawQuorumRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGov(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if m.ConstitutionAmendmentQuorumRange != nil {
		{
			size, err := m.ConstitutionAmendmentQuorumRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGov(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.QuorumRange != nil {
		{
			size, err := m.QuorumRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGov(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if len(m.BurnDepositNoThreshold) > 0 {
		i -= len(m.BurnDepositNoThreshold)
		copy(dAtA[i:], m.BurnDepositNoThreshold)
		i = encodeVarintGov(dAtA, i, uint64(len(m.BurnDepositNoThreshold)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.MinInitialDepositThrottler != nil {
		{
			size, err := m.MinInitialDepositThrottler.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGov(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.MinDepositThrottler != nil {
		{
			size, err := m.MinDepositThrottler.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGov(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.QuorumCheckCount != 0 {
		i = encodeVarintGov(dAtA, i, uint64(m.QuorumCheckCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.MaxVotingPeriodExtension != nil {
		n17, err17 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(*m.MaxVotingPeriodExtension, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.MaxVotingPeriodExtension):])
		if err17 != nil {
			return 0, err17
		}
		i -= n17
		i = encodeVarintGov(dAtA, i, uint64(n17))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.QuorumTimeout != nil {
		n18, err18 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(*m.QuorumTimeout, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.QuorumTimeout):])
		if err18 != nil {
			return 0, err18
		}
		i -= n18
		i = encodeVarintGov(dAtA, i, uint64(n18))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.LawThreshold) > 0 {
		i -= len(m.LawThreshold)
		copy(dAtA[i:], m.LawThreshold)
		i = encodeVarintGov(dAtA, i, uint64(len(m.LawThreshold)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.LawQuorum) > 0 {
		i -= len(m.LawQuorum)
		copy(dAtA[i:], m.LawQuorum)
		i = encodeVarintGov(dAtA, i, uint64(len(m.LawQuorum)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.ConstitutionAmendmentThreshold) > 0 {
		i -= len(m.ConstitutionAmendmentThreshold)
		copy(dAtA[i:], m.ConstitutionAmendmentThreshold)
		i = encodeVarintGov(dAtA, i, uint64(len(m.ConstitutionAmendmentThreshold)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.ConstitutionAmendmentQuorum) > 0 {
		i -= len(m.ConstitutionAmendmentQuorum)
		copy(dAtA[i:], m.ConstitutionAmendmentQuorum)
		i = encodeVarintGov(dAtA, i, uint64(len(m.ConstitutionAmendmentQuorum)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.MinDepositRatio) > 0 {
		i -= len(m.MinDepositRatio)
		copy(dAtA[i:], m.MinDepositRatio)
		i = encodeVarintGov(dAtA, i, uint64(len(m.MinDepositRatio)))
		i--
		dAtA[i] = 0x7a
	}
	if m.BurnProposalDepositPrevote {
		i--
		if m.BurnProposalDepositPrevote {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.BurnVoteQuorum {
		i--
		if m.BurnVoteQuorum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if len(m.MinInitialDepositRatio) > 0 {
		i -= len(m.MinInitialDepositRatio)
		copy(dAtA[i:], m.MinInitialDepositRatio)
		i = encodeVarintGov(dAtA, i, uint64(len(m.MinInitialDepositRatio)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Threshold) > 0 {
		i -= len(m.Threshold)
		copy(dAtA[i:], m.Threshold)
		i = encodeVarintGov(dAtA, i, uint64(len(m.Threshold)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Quorum) > 0 {
		i -= len(m.Quorum)
		copy(dAtA[i:], m.Quorum)
		i = encodeVarintGov(dAtA, i, uint64(len(m.Quorum)))
		i--
		dAtA[i] = 0x22
	}
	if m.VotingPeriod != nil {
		n19, err19 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(*m.VotingPeriod, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.VotingPeriod):])
		if err19 != nil {
			return 0, err19
		}
		i -= n19
		i = encodeVarintGov(dAtA, i, uint64(n19))
		i--
		dAtA[i] = 0x1a
	}
	if m.MaxDepositPeriod != nil {
		n20, err20 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(*m.MaxDepositPeriod, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.MaxDepositPeriod):])
		if err20 != nil {
			return 0, err20
		}
		i -= n20
		i = encodeVarintGov(dAtA, i, uint64(n20))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MinDeposit) > 0 {
		for iNdEx := len(m.MinDeposit) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MinDeposit[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGov(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QuorumRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuorumRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuorumRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Min) > 0 {
		i -= len(m.Min)
		copy(dAtA[i:], m.Min)
		i = encodeVarintGov(dAtA, i, uint64(len(m.Min)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Max) > 0 {
		i -= len(m.Max)
		copy(dAtA[i:], m.Max)
		i = encodeVarintGov(dAtA, i, uint64(len(m.Max)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintGov(dAtA []byte, offset int, v uint64) int {
	offset -= sovGov(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *WeightedVoteOption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Option != 0 {
		n += 1 + sovGov(uint64(m.Option))
	}
	l = len(m.Weight)
	if l > 0 {
		n += 1 + l + sovGov(uint64(l))
	}
	return n
}

func (m *Deposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalId != 0 {
		n += 1 + sovGov(uint64(m.ProposalId))
	}
	l = len(m.Depositor)
	if l > 0 {
		n += 1 + l + sovGov(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovGov(uint64(l))
		}
	}
	return n
}

func (m *LastMinDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Value) > 0 {
		for _, e := range m.Value {
			l = e.Size()
			n += 1 + l + sovGov(uint64(l))
		}
	}
	if m.Time != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.Time)
		n += 1 + l + sovGov(uint64(l))
	}
	return n
}

func (m *Proposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGov(uint64(m.Id))
	}
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovGov(uint64(l))
		}
	}
	if m.Status != 0 {
		n += 1 + sovGov(uint64(m.Status))
	}
	if m.FinalTallyResult != nil {
		l = m.FinalTallyResult.Size()
		n += 1 + l + sovGov(uint64(l))
	}
	if m.SubmitTime != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.SubmitTime)
		n += 1 + l + sovGov(uint64(l))
	}
	if m.DepositEndTime != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.DepositEndTime)
		n += 1 + l + sovGov(uint64(l))
	}
	if len(m.TotalDeposit) > 0 {
		for _, e := range m.TotalDeposit {
			l = e.Size()
			n += 1 + l + sovGov(uint64(l))
		}
	}
	if m.VotingStartTime != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.VotingStartTime)
		n += 1 + l + sovGov(uint64(l))
	}
	if m.VotingEndTime != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.VotingEndTime)
		n += 1 + l + sovGov(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovGov(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovGov(uint64(l))
	}
	l = len(m.Summary)
	if l > 0 {
		n += 1 + l + sovGov(uint64(l))
	}
	l = len(m.Proposer)
	if l > 0 {
		n += 1 + l + sovGov(uint64(l))
	}
	if m.Endorsed {
		n += 2
	}
	l = len(m.Annotation)
	if l > 0 {
		n += 1 + l + sovGov(uint64(l))
	}
	if m.TimesVotingPeriodExtended != 0 {
		n += 2 + sovGov(uint64(m.TimesVotingPeriodExtended))
	}
	return n
}

func (m *TallyResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.YesCount)
	if l > 0 {
		n += 1 + l + sovGov(uint64(l))
	}
	l = len(m.AbstainCount)
	if l > 0 {
		n += 1 + l + sovGov(uint64(l))
	}
	l = len(m.NoCount)
	if l > 0 {
		n += 1 + l + sovGov(uint64(l))
	}
	return n
}

func (m *Vote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalId != 0 {
		n += 1 + sovGov(uint64(m.ProposalId))
	}
	l = len(m.Voter)
	if l > 0 {
		n += 1 + l + sovGov(uint64(l))
	}
	if len(m.Options) > 0 {
		for _, e := range m.Options {
			l = e.Size()
			n += 1 + l + sovGov(uint64(l))
		}
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovGov(uint64(l))
	}
	return n
}

func (m *QuorumCheckQueueEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QuorumTimeoutTime != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.QuorumTimeoutTime)
		n += 1 + l + sovGov(uint64(l))
	}
	if m.QuorumCheckCount != 0 {
		n += 1 + sovGov(uint64(m.QuorumCheckCount))
	}
	if m.QuorumChecksDone != 0 {
		n += 1 + sovGov(uint64(m.QuorumChecksDone))
	}
	return n
}

func (m *DepositParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MinDeposit) > 0 {
		for _, e := range m.MinDeposit {
			l = e.Size()
			n += 1 + l + sovGov(uint64(l))
		}
	}
	if m.MaxDepositPeriod != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.MaxDepositPeriod)
		n += 1 + l + sovGov(uint64(l))
	}
	return n
}

func (m *VotingParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VotingPeriod != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.VotingPeriod)
		n += 1 + l + sovGov(uint64(l))
	}
	return n
}

func (m *TallyParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Quorum)
	if l > 0 {
		n += 1 + l + sovGov(uint64(l))
	}
	l = len(m.Threshold)
	if l > 0 {
		n += 1 + l + sovGov(uint64(l))
	}
	l = len(m.ConstitutionAmendmentQuorum)
	if l > 0 {
		n += 1 + l + sovGov(uint64(l))
	}
	l = len(m.ConstitutionAmendmentThreshold)
	if l > 0 {
		n += 1 + l + sovGov(uint64(l))
	}
	l = len(m.LawQuorum)
	if l > 0 {
		n += 1 + l + sovGov(uint64(l))
	}
	l = len(m.LawThreshold)
	if l > 0 {
		n += 1 + l + sovGov(uint64(l))
	}
	return n
}

func (m *MinDepositThrottler) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FloorValue) > 0 {
		for _, e := range m.FloorValue {
			l = e.Size()
			n += 1 + l + sovGov(uint64(l))
		}
	}
	if m.UpdatePeriod != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.UpdatePeriod)
		n += 1 + l + sovGov(uint64(l))
	}
	if m.TargetActiveProposals != 0 {
		n += 1 + sovGov(uint64(m.TargetActiveProposals))
	}
	l = len(m.IncreaseRatio)
	if l > 0 {
		n += 1 + l + sovGov(uint64(l))
	}
	l = len(m.DecreaseRatio)
	if l > 0 {
		n += 1 + l + sovGov(uint64(l))
	}
	if m.DecreaseSensitivityTargetDistance != 0 {
		n += 1 + sovGov(uint64(m.DecreaseSensitivityTargetDistance))
	}
	return n
}

func (m *MinInitialDepositThrottler) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FloorValue) > 0 {
		for _, e := range m.FloorValue {
			l = e.Size()
			n += 1 + l + sovGov(uint64(l))
		}
	}
	if m.UpdatePeriod != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.UpdatePeriod)
		n += 1 + l + sovGov(uint64(l))
	}
	if m.TargetProposals != 0 {
		n += 1 + sovGov(uint64(m.TargetProposals))
	}
	l = len(m.IncreaseRatio)
	if l > 0 {
		n += 1 + l + sovGov(uint64(l))
	}
	l = len(m.DecreaseRatio)
	if l > 0 {
		n += 1 + l + sovGov(uint64(l))
	}
	if m.DecreaseSensitivityTargetDistance != 0 {
		n += 1 + sovGov(uint64(m.DecreaseSensitivityTargetDistance))
	}
	return n
}

func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MinDeposit) > 0 {
		for _, e := range m.MinDeposit {
			l = e.Size()
			n += 1 + l + sovGov(uint64(l))
		}
	}
	if m.MaxDepositPeriod != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.MaxDepositPeriod)
		n += 1 + l + sovGov(uint64(l))
	}
	if m.VotingPeriod != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.VotingPeriod)
		n += 1 + l + sovGov(uint64(l))
	}
	l = len(m.Quorum)
	if l > 0 {
		n += 1 + l + sovGov(uint64(l))
	}
	l = len(m.Threshold)
	if l > 0 {
		n += 1 + l + sovGov(uint64(l))
	}
	l = len(m.MinInitialDepositRatio)
	if l > 0 {
		n += 1 + l + sovGov(uint64(l))
	}
	if m.BurnVoteQuorum {
		n += 2
	}
	if m.BurnProposalDepositPrevote {
		n += 2
	}
	l = len(m.MinDepositRatio)
	if l > 0 {
		n += 1 + l + sovGov(uint64(l))
	}
	l = len(m.ConstitutionAmendmentQuorum)
	if l > 0 {
		n += 2 + l + sovGov(uint64(l))
	}
	l = len(m.ConstitutionAmendmentThreshold)
	if l > 0 {
		n += 2 + l + sovGov(uint64(l))
	}
	l = len(m.LawQuorum)
	if l > 0 {
		n += 2 + l + sovGov(uint64(l))
	}
	l = len(m.LawThreshold)
	if l > 0 {
		n += 2 + l + sovGov(uint64(l))
	}
	if m.QuorumTimeout != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.QuorumTimeout)
		n += 2 + l + sovGov(uint64(l))
	}
	if m.MaxVotingPeriodExtension != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.MaxVotingPeriodExtension)
		n += 2 + l + sovGov(uint64(l))
	}
	if m.QuorumCheckCount != 0 {
		n += 2 + sovGov(uint64(m.QuorumCheckCount))
	}
	if m.MinDepositThrottler != nil {
		l = m.MinDepositThrottler.Size()
		n += 2 + l + sovGov(uint64(l))
	}
	if m.MinInitialDepositThrottler != nil {
		l = m.MinInitialDepositThrottler.Size()
		n += 2 + l + sovGov(uint64(l))
	}
	l = len(m.BurnDepositNoThreshold)
	if l > 0 {
		n += 2 + l + sovGov(uint64(l))
	}
	if m.QuorumRange != nil {
		l = m.QuorumRange.Size()
		n += 2 + l + sovGov(uint64(l))
	}
	if m.ConstitutionAmendmentQuorumRange != nil {
		l = m.ConstitutionAmendmentQuorumRange.Size()
		n += 2 + l + sovGov(uint64(l))
	}
	if m.LawQuorumRange != nil {
		l = m.LawQuorumRange.Size()
		n += 2 + l + sovGov(uint64(l))
	}
	return n
}

func (m *QuorumRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Max)
	if l > 0 {
		n += 1 + l + sovGov(uint64(l))
	}
	l = len(m.Min)
	if l > 0 {
		n += 1 + l + sovGov(uint64(l))
	}
	return n
}

func sovGov(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGov(x uint64) (n int) {
	return sovGov(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *WeightedVoteOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGov
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WeightedVoteOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WeightedVoteOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			m.Option = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Option |= VoteOption(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Weight = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGov(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGov
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGov
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Deposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Deposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Depositor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Depositor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, types.Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGov(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGov
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LastMinDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGov
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LastMinDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LastMinDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, types.Coin{})
			if err := m.Value[len(m.Value)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Time == nil {
				m.Time = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.Time, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGov(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGov
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGov
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Proposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Proposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &types1.Any{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ProposalStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalTallyResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FinalTallyResult == nil {
				m.FinalTallyResult = &TallyResult{}
			}
			if err := m.FinalTallyResult.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmitTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubmitTime == nil {
				m.SubmitTime = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.SubmitTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositEndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DepositEndTime == nil {
				m.DepositEndTime = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.DepositEndTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDeposit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalDeposit = append(m.TotalDeposit, types.Coin{})
			if err := m.TotalDeposit[len(m.TotalDeposit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingStartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VotingStartTime == nil {
				m.VotingStartTime = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.VotingStartTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingEndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VotingEndTime == nil {
				m.VotingEndTime = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.VotingEndTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Summary = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proposer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endorsed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Endorsed = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Annotation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimesVotingPeriodExtended", wireType)
			}
			m.TimesVotingPeriodExtended = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimesVotingPeriodExtended |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGov(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGov
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TallyResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGov
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TallyResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TallyResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YesCount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.YesCount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbstainCount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AbstainCount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoCount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NoCount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGov(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGov
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGov
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Voter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, &WeightedVoteOption{})
			if err := m.Options[len(m.Options)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGov(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGov
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuorumCheckQueueEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGov
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuorumCheckQueueEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuorumCheckQueueEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuorumTimeoutTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QuorumTimeoutTime == nil {
				m.QuorumTimeoutTime = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.QuorumTimeoutTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuorumCheckCount", wireType)
			}
			m.QuorumCheckCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QuorumCheckCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuorumChecksDone", wireType)
			}
			m.QuorumChecksDone = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QuorumChecksDone |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGov(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGov
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DepositParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGov
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DepositParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DepositParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDeposit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinDeposit = append(m.MinDeposit, types.Coin{})
			if err := m.MinDeposit[len(m.MinDeposit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDepositPeriod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxDepositPeriod == nil {
				m.MaxDepositPeriod = new(time.Duration)
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(m.MaxDepositPeriod, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGov(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGov
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VotingParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGov
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VotingParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VotingParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingPeriod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VotingPeriod == nil {
				m.VotingPeriod = new(time.Duration)
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(m.VotingPeriod, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGov(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGov
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TallyParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGov
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TallyParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TallyParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quorum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Quorum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Threshold = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstitutionAmendmentQuorum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConstitutionAmendmentQuorum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstitutionAmendmentThreshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConstitutionAmendmentThreshold = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LawQuorum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LawQuorum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LawThreshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LawThreshold = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGov(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGov
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MinDepositThrottler) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGov
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MinDepositThrottler: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MinDepositThrottler: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloorValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FloorValue = append(m.FloorValue, types.Coin{})
			if err := m.FloorValue[len(m.FloorValue)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatePeriod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatePeriod == nil {
				m.UpdatePeriod = new(time.Duration)
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(m.UpdatePeriod, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetActiveProposals", wireType)
			}
			m.TargetActiveProposals = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetActiveProposals |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncreaseRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IncreaseRatio = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecreaseRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DecreaseRatio = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecreaseSensitivityTargetDistance", wireType)
			}
			m.DecreaseSensitivityTargetDistance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DecreaseSensitivityTargetDistance |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGov(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGov
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MinInitialDepositThrottler) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGov
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MinInitialDepositThrottler: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MinInitialDepositThrottler: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloorValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FloorValue = append(m.FloorValue, types.Coin{})
			if err := m.FloorValue[len(m.FloorValue)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatePeriod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatePeriod == nil {
				m.UpdatePeriod = new(time.Duration)
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(m.UpdatePeriod, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetProposals", wireType)
			}
			m.TargetProposals = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetProposals |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncreaseRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IncreaseRatio = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecreaseRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DecreaseRatio = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecreaseSensitivityTargetDistance", wireType)
			}
			m.DecreaseSensitivityTargetDistance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DecreaseSensitivityTargetDistance |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGov(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGov
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGov
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDeposit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinDeposit = append(m.MinDeposit, types.Coin{})
			if err := m.MinDeposit[len(m.MinDeposit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDepositPeriod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxDepositPeriod == nil {
				m.MaxDepositPeriod = new(time.Duration)
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(m.MaxDepositPeriod, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingPeriod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VotingPeriod == nil {
				m.VotingPeriod = new(time.Duration)
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(m.VotingPeriod, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quorum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Quorum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Threshold = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinInitialDepositRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinInitialDepositRatio = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnVoteQuorum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BurnVoteQuorum = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnProposalDepositPrevote", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BurnProposalDepositPrevote = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDepositRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinDepositRatio = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstitutionAmendmentQuorum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConstitutionAmendmentQuorum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstitutionAmendmentThreshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConstitutionAmendmentThreshold = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LawQuorum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LawQuorum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LawThreshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LawThreshold = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuorumTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QuorumTimeout == nil {
				m.QuorumTimeout = new(time.Duration)
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(m.QuorumTimeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxVotingPeriodExtension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxVotingPeriodExtension == nil {
				m.MaxVotingPeriodExtension = new(time.Duration)
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(m.MaxVotingPeriodExtension, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuorumCheckCount", wireType)
			}
			m.QuorumCheckCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QuorumCheckCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDepositThrottler", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MinDepositThrottler == nil {
				m.MinDepositThrottler = &MinDepositThrottler{}
			}
			if err := m.MinDepositThrottler.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinInitialDepositThrottler", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MinInitialDepositThrottler == nil {
				m.MinInitialDepositThrottler = &MinInitialDepositThrottler{}
			}
			if err := m.MinInitialDepositThrottler.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnDepositNoThreshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BurnDepositNoThreshold = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuorumRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QuorumRange == nil {
				m.QuorumRange = &QuorumRange{}
			}
			if err := m.QuorumRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstitutionAmendmentQuorumRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConstitutionAmendmentQuorumRange == nil {
				m.ConstitutionAmendmentQuorumRange = &QuorumRange{}
			}
			if err := m.ConstitutionAmendmentQuorumRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LawQuorumRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LawQuorumRange == nil {
				m.LawQuorumRange = &QuorumRange{}
			}
			if err := m.LawQuorumRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGov(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGov
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuorumRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGov
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuorumRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuorumRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Max = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Min", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGov
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGov
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGov
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Min = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGov(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGov
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGov(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGov
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGov
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGov
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGov
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGov
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGov
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGov        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGov          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGov = fmt.Errorf("proto: unexpected end of group")
)
