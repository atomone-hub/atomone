package e2e

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"time"

	providertypes "github.com/allinbits/interchain-security/x/ccv/provider/types"
)

// createConsumerChain creates a new consumer chain with the specified chain ID.
// The consumer chain uses the ICS consumer daemon binary.
func (s *IntegrationTestSuite) createConsumerChain(consumerChainID string) (*chain, error) {
	s.T().Logf("Creating consumer chain: %s", consumerChainID)

	consumerChain, err := newChainWithType(chainTypeConsumer)
	if err != nil {
		return nil, err
	}

	// Override the chain ID with the one specified
	consumerChain.id = consumerChainID

	return consumerChain, nil
}

// queryConsumerGenesis queries the consumer genesis from the provider chain.
// This genesis is generated by the provider after a consumer addition proposal passes
// and the spawn time is reached.
func (s *IntegrationTestSuite) queryConsumerGenesis(
	providerChain *chain,
	consumerChainID string,
) ([]byte, error) {
	s.T().Logf("Querying consumer genesis for chain %s from provider", consumerChainID)

	endpoint := fmt.Sprintf("http://%s", s.valResources[providerChain.id][0].GetHostPort("1317/tcp"))

	// Query consumer genesis from provider
	// GET /interchain_security/ccv/provider/consumer_genesis/{chain_id}
	body, err := httpGet(fmt.Sprintf("%s/interchain_security/ccv/provider/consumer_genesis/%s", endpoint, consumerChainID))
	if err != nil {
		return nil, fmt.Errorf("failed to query consumer genesis: %w", err)
	}

	var resp providertypes.QueryConsumerGenesisResponse
	if err := s.cdc.UnmarshalJSON(body, &resp); err != nil {
		return nil, fmt.Errorf("failed to unmarshal consumer genesis response: %w", err)
	}

	// The genesis state returned is the CCV consumer genesis state
	// We need to marshal it back to JSON for merging with the base consumer chain genesis
	ccvGenesisJSON, err := s.cdc.MarshalJSON(&resp.GenesisState)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal CCV genesis: %w", err)
	}

	return ccvGenesisJSON, nil
}

// mergeConsumerGenesis merges the CCV genesis state with the base consumer chain genesis.
// The CCV genesis contains validator sets and provider info that must be integrated
// into the consumer chain's genesis file.
func (s *IntegrationTestSuite) mergeConsumerGenesis(
	consumerChain *chain,
	ccvGenesisJSON []byte,
) error {
	s.T().Logf("Merging CCV genesis into consumer chain %s", consumerChain.id)

	// Read the base genesis file from the consumer chain
	genesisPath := filepath.Join(consumerChain.validators[0].configDir(), "config", "genesis.json")

	baseGenesis, err := os.ReadFile(genesisPath)
	if err != nil {
		return fmt.Errorf("failed to read base genesis: %w", err)
	}

	// Parse base genesis
	var baseGenesisMap map[string]interface{}
	if err := json.Unmarshal(baseGenesis, &baseGenesisMap); err != nil {
		return fmt.Errorf("failed to unmarshal base genesis: %w", err)
	}

	// Parse CCV genesis
	var ccvGenesisMap map[string]interface{}
	if err := json.Unmarshal(ccvGenesisJSON, &ccvGenesisMap); err != nil {
		return fmt.Errorf("failed to unmarshal CCV genesis: %w", err)
	}

	// Merge CCV genesis into app_state.ccvconsumer
	appState, ok := baseGenesisMap["app_state"].(map[string]interface{})
	if !ok {
		return fmt.Errorf("invalid genesis format: app_state not found")
	}

	appState["ccvconsumer"] = ccvGenesisMap

	// Write merged genesis back to file
	mergedGenesis, err := json.MarshalIndent(baseGenesisMap, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal merged genesis: %w", err)
	}

	if err := writeFile(genesisPath, mergedGenesis); err != nil {
		return fmt.Errorf("failed to write merged genesis: %w", err)
	}

	// Copy the merged genesis to all validators
	for _, val := range consumerChain.validators[1:] {
		valGenesisPath := filepath.Join(val.configDir(), "config", "genesis.json")
		if err := writeFile(valGenesisPath, mergedGenesis); err != nil {
			return fmt.Errorf("failed to copy merged genesis to validator %d: %w", val.index, err)
		}
	}

	// Verify the merge was successful by checking for provider.initial_val_set
	if ccvConsumer, ok := appState["ccvconsumer"].(map[string]interface{}); ok {
		if provider, ok := ccvConsumer["provider"].(map[string]interface{}); ok {
			if initialValSet, ok := provider["initial_val_set"].([]interface{}); ok {
				if len(initialValSet) == 0 {
					return fmt.Errorf("provider.initial_val_set is empty - consumer chain will fail to start")
				}
			}
		}
	} else {
		return fmt.Errorf("ccvconsumer module not found in merged genesis")
	}

	return nil
}

// startConsumerChain starts the consumer chain validators.
// This should be called after the consumer genesis has been merged.
func (s *IntegrationTestSuite) startConsumerChain(consumerChain *chain) error {
	s.T().Logf("Starting consumer chain: %s", consumerChain.id)

	// Use the standard runValidators function which already handles consumer chains
	// Port offset of 100 to avoid conflicts with provider (provider uses 0)
	s.runValidators(consumerChain, 100)

	// Wait for chain to start producing blocks
	s.T().Logf("Waiting for consumer chain %s to start...", consumerChain.id)
	time.Sleep(10 * time.Second)

	return nil
}

// waitForConsumerChainSpawnTime waits for the consumer chain spawn time to be reached.
// The provider will only generate consumer genesis after the spawn time.
func (s *IntegrationTestSuite) waitForConsumerChainSpawnTime(
	ctx context.Context,
	providerChain *chain,
	consumerChainID string,
) error {
	s.T().Logf("Waiting for consumer chain %s spawn time...", consumerChainID)

	endpoint := fmt.Sprintf("http://%s", s.valResources[providerChain.id][0].GetHostPort("1317/tcp"))

	// Poll until spawn time is reached and consumer genesis is available
	// With 30s spawn time and 15s voting period, this should succeed within 30-40 seconds
	ticker := time.NewTicker(2 * time.Second)
	defer ticker.Stop()

	timeout := time.After(2 * time.Minute)

	for {
		select {
		case <-ctx.Done():
			return ctx.Err()
		case <-timeout:
			return fmt.Errorf("timeout waiting for consumer chain spawn time")
		case <-ticker.C:
			// Check if genesis is available (means spawn time reached)
			body, err := httpGet(fmt.Sprintf("%s/interchain_security/ccv/provider/consumer_genesis/%s", endpoint, consumerChainID))
			if err == nil {
				var resp providertypes.QueryConsumerGenesisResponse
				if err := s.cdc.UnmarshalJSON(body, &resp); err == nil {
					s.T().Logf("Consumer chain %s spawn time reached, genesis available", consumerChainID)
					return nil
				}
			}
		}
	}
}

// assertConsumerChainHeight verifies that the consumer chain is producing blocks.
func (s *IntegrationTestSuite) assertConsumerChainHeight(consumerChain *chain, minHeight int64) {
	s.T().Logf("Verifying consumer chain %s is at height >= %d", consumerChain.id, minHeight)

	endpoint := fmt.Sprintf("http://%s", s.valResources[consumerChain.id][0].GetHostPort("1317/tcp"))

	s.Require().Eventually(
		func() bool {
			body, err := httpGet(fmt.Sprintf("%s/cosmos/base/tendermint/v1beta1/blocks/latest", endpoint))
			if err != nil {
				s.T().Logf("Error querying consumer chain height: %v", err)
				return false
			}

			var response struct {
				Block struct {
					Header struct {
						Height string `json:"height"`
					} `json:"header"`
				} `json:"block"`
			}

			if err := json.Unmarshal(body, &response); err != nil {
				s.T().Logf("Error unmarshaling height response: %v", err)
				return false
			}

			height, err := strconv.ParseInt(response.Block.Header.Height, 10, 64)
			if err != nil {
				s.T().Logf("Error parsing height: %v", err)
				return false
			}
			s.T().Logf("Consumer chain %s current height: %d", consumerChain.id, height)
			return height >= minHeight
		},
		1*time.Minute,
		2*time.Second,
		"consumer chain failed to reach minimum height",
	)
}
